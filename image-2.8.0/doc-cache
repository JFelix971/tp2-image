# doc-cache created by Octave 4.2.2
# name: cache
# type: cell
# rows: 3
# columns: 145
# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
analyze75info


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 570
 -- Function File: HEADER = analyze75info (FILENAME)
 -- Function File: HEADER = analyze75info (FILENAME, "ByteOrder", ARCH)
     Read header of an Analyze 7.5 file.

     FILENAME must be the path for an Analyze 7.5 file or the path for a
     directory with a single .hdr file can be specified.

     The optional argument '"ByteOrder"' reads the file with the
     specified ARCH ("ieee-be" or "ieee-le" for IEEE big endian or IEEE
     little endian respectively).

     HEADER is a structure with the file information.

     See also: analyze75read, analyze75write.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Read header of an Analyze 7.5 file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
analyze75read


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 410
 -- Function File: IMAGE = analyze75read (FILENAME)
 -- Function File: IMAGE = analyze75read (HEADER)
     Read image data of an Analyze 7.5 file.

     FILENAME must be the path for an Analyze 7.5 file or the path for a
     directory with a single .hdr file can be specified.  Alternatively,
     the file HEADER can be specified as returned by 'analyze75info'.

     See also: analyze75info, analyze75write.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Read image data of an Analyze 7.5 file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
analyze75write


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 502
 -- Function File: analyze75write (FILENAME, DATA, HEADER)
 -- Function File: analyze75write (FILENAME, DATA, X, Y, Z)
 -- Function File: analyze75write (FILENAME, DATA, HEADER, X, Y, Z)
     Write image data to an Analyze 7.5 file.

     FILENAME is the path to write the Analyze 7.5 file; DATA is the 3D
     image data; HEADER is a structure containing the file information;
     X, Y, Z are lists of the x,y,z coordinates (in cm) of the data
     grid.

     See also: analyze75info, analyze75read.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Write image data to an Analyze 7.5 file.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
applylut


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 554
 -- Function File: A = applylut (BW, LUT)
     Uses lookup tables to perform a neighbour operation on binary
     images.

     A = applylut(BW,LUT) returns the result of a neighbour operation
     using the lookup table LUT which can be created by makelut.

     It first computes a matrix with the index of each element in the
     lookup table.  To do this, it convolves the original matrix with a
     matrix which assigns each of the neighbours a bit in the resulting
     index.  Then LUT is accessed to compute the result.

     See also: makelut.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Uses lookup tables to perform a neighbour operation on binary images.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
bestblk


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 914
 -- Function File: BLK_SIZE = bestblk (IMS)
 -- Function File: BLK_SIZE = bestblk (IMS, MAX)
 -- Function File: [MB, NB, ...] = bestblk (...)
     Calculate block best size for block processing.

     Given a matrix of size IMS, calculates the largest size for
     distinct blocks BLK_SIZE, that minimize padding and is smaller than
     or equal to K (defaults to 100)

     The output BLK_SIZE is a row vector for the block size.  If there
     are multiple output arguments, the number of rows is assigned to
     the first (MB), and the number of columns to the second (NB), etc.

     To determine BLK_SIZE, the following is performed for each
     dimension:

       1. If dimension IMS is less or equal than K, it returns the
          dimension value.

       2. If not, find the highest value between 'min (dimension/10,
          k/2)' which minimizes padding.

     See also: blockproc, col2im, im2col.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Calculate block best size for block processing.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
blockproc


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1457
 -- Function File: B = blockproc (A, [M,N], FUN)
 -- Function File: B = blockproc (A, [M,N], FUN, ...)
 -- Function File: B = blockproc (A, [M,N], [MBORDER,NBORDER], FUN, ...)
 -- Function File: B = blockproc (A, 'indexed', ...)
     Processes image in blocks using user-supplied function.

     'B=blockproc(A,[m,n],fun)' divides image A in M-by-N blocks, and
     passes them to user-supplied function FUN, which result is
     concatenated to build returning matrix B.  If padding is needed to
     build M-by-N, it is added at the bottom and right borders of the
     image.  0 is used as a padding value.

     'B=blockproc(A,[m,n],fun, ...)' behaves as described above but
     passes extra parameters to function FUN.

     'B=blockproc(A,[m,n],[mborder,nborder],fun, ...)' behaves as
     described but uses blocks which overlap with neighbour blocks.
     Overlapping dimensions are MBORDER vertically and NBORDER
     horizontally.  This doesn't change the number of blocks in an image
     (which depends only on size(A) and [M,N]).  Adding a border
     requires extra padding on all edges of the image.  0 is used as a
     padding value.

     'B=blockproc(A,'indexed', ...)' assumes that A is an indexed image,
     so it pads the image using proper value: 0 for uint8 and uint16
     images and 1 for double images.  Keep in mind that if 'indexed' is
     not specified padding is always done using 0.

     See also: colfilt,inline,bestblk.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Processes image in blocks using user-supplied function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
bwarea


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 534
 -- Function File: TOTAL = bwarea (BW)
     Estimate total area of objects on the image BW.

     The image BW can be of any class, even non-logical, in which case
     non zero valued pixels are considered to be an object.

     This algorithm is not the same as counting the number of pixels
     belonging to an object as it tries to estimate the area of the
     original object.  The value of each pixel to the total area is
     weighted in relation to its neighbour pixels.

     See also: im2bw, bweuler, bwperim, regionprops.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Estimate total area of objects on the image BW.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
bwareafilt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1012
 -- Function File: bwareafilt (BW, RANGE)
 -- Function File: bwareafilt (BW, N)
 -- Function File: bwareafilt (BW, N, KEEP)
 -- Function File: bwareafilt (..., CONN)
     Filter objects from image based on their sizes.

     Returns a logical matrix with the objects of BW filtered based on
     their area (defined by thei number of pixels).  This function is
     equivalent to 'bwpropfilt (BW, "Area", ...)'.

     To filter objects with a value on a specific interval, RANGE must
     be a two-element vector with the interval '[LOW HIGH]' (values are
     inclusive).

     Alternatively, a scalar N will select the objects with the N
     highest values.  The KEEP option defaults to "largest" but can also
     be set to "smallest" to select the N objects with lower values.

     The last optional argument, CONN, can be a connectivity matrix, or
     the number of elements connected to the center (see 'conndef').

     See also: bwareaopen, bwlabel, bwlabeln, bwconncomp, bwpropfilt,
     regionprops.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Filter objects from image based on their sizes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
bwboundaries


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1295
 -- Function File: BOUNDARIES = bwboundaries(BW)
 -- Function File: BOUNDARIES = bwboundaries(BW, CONN)
 -- Function File: BOUNDARIES = bwboundaries(BW, CONN, HOLES)
 -- Function File: [BOUNDARIES, LABELS] = bwboundaries(...)
 -- Function File: [BOUNDARIES, LABELS, NUM_LABELS] = bwboundaries(...)
     Trace the boundaries of the objects in a binary image.

     BOUNDARIES is a cell array in which each element is the boundary of
     an object in the binary image BW.  The clockwise boundary of each
     object is computed by the 'boundary' function.

     By default the boundaries are computed using 8-connectivity.  This
     can be changed to 4-connectivity by setting CONN to 4.

     By default 'bwboundaries' computes all boundaries in the image,
     i.e.  both interior and exterior object boundaries.  This behaviour
     can be changed through the HOLES input argument.  If this is
     'holes', both boundary types are considered.  If it is instead
     'noholes', only exterior boundaries will be traced.

     If two or more output arguments are requested, the algorithm also
     returns the labelled image computed by 'bwlabel' in LABELS.  The
     number of labels in this image is optionally returned in
     NUM_LABELS.

     See also: bwlabel, bwlabeln, bwperim, fchcode.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 54
Trace the boundaries of the objects in a binary image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
bweuler


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 661
 -- Function File: EUL = bweuler (BW, N)
     Calculate the Euler number of a binary image.

     This function calculates the Euler number EUL of a binary image BW.
     This number is a scalar whose value represents the total number of
     objects in BW minus the number of holes.

     N is an optional argument that specifies the neighbourhood
     connectivity.  Must either be 4 or 8.  If omitted, defaults to 8.

     This function uses Bit Quads as described in "Digital Image
     Processing" to calculate euler number.

     References: W. K. Pratt, "Digital Image Processing", 3rd Edition,
     pp 593-595

     See also: bwmorph, bwperim, qtgetblk.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Calculate the Euler number of a binary image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
bwhitmiss


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1220
 -- Function File: bwhitmiss (BW, SE1, SE2)
 -- Function File: bwhitmiss (BW, INTERVAL)
     Perform binary hit-or-miss transform.

     This transform returns the set of positions, where the structuring
     element SE1 fits in the foregrond of BW, while the structuring
     element SE2 misses it completely.  It is equivalent to:

          imerode (BW, SE1) & imerode (! BW, SE2)

     For example, the following will remove every pixel with adjacent
     horizontal foreground pixels:

          >> bw = [ 0   1   0   1   1   0
                    0   1   0   1   1   0
                    0   1   0   1   1   0];

          >> bwhitmiss (bw, [1; 0; 1], [1 0 1])
            => ans =

                    0   1   0   0   0   0
                    0   1   0   0   0   0
                    0   1   0   0   0   0

     Note that while SE1 and SE2 must have disjoint neighbourhoods for
     this transform to be meaningful, no error or warning is throw about
     it.

     Alternatively a single array INTERVAL can be defined, of values
     from '[1 0 -1]'.  In this case, the two structuring elements are
     extracted as:

          SE1 = (INTERVAL ==  1)
          SE2 = (INTERVAL == -1)

     See also: bwmorph.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Perform binary hit-or-miss transform.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
bwmorph


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7800
 -- Function File: bwmorph (BW, OPERATION)
 -- Function File: bwmorph (BW, OPERATION, N)
     Perform morphological operation on binary image.

     For a binary image BW, performs the morphological OPERATION, N
     times.  All possible values of OPERATION are listed on the table
     below.  By default, N is 1.  If N is 'Inf', the operation is
     continually performed until it no longer changes the image.

     In some operations, BW can be a binary matrix with any number of
     dimensions (see details on the table of operations).

     Note that the output will always be of class logical, independently
     of the class of BW.

     'bothat'
          Performs a bottom hat operation, a closing operation (which is
          a dilation followed by an erosion) and finally subtracts the
          original image (see 'imbothat').  BW can have any number of
          dimensions, and 'strel ("hypercube", ndims (BW), 3)' is used
          as structuring element.

     'bridge'
          Performs a bridge operation.  Sets a pixel to 1 if it has two
          nonzero neighbours which are not connected, so it "bridges"
          them.  There are 119 3-by-3 patterns which trigger setting a
          pixel to 1.

     'clean'
          Performs an isolated pixel remove operation.  Sets a pixel to
          0 if all of its eight-connected neighbours are 0.  BW can have
          any number of dimensions in which case connectivity is
          '(3^ndims(BW)) -1', i.e., all of the elements around it.

     'close'
          Performs closing operation, which is a dilation followed by
          erosion (see 'imclose').  BW can have any number of
          dimensions, and 'strel ("hypercube", ndims (BW), 3)' is used
          as structuring element.

     'diag'
          Performs a diagonal fill operation.  Sets a pixel to 1 if that
          eliminates eight-connectivity of the background.

     'dilate'
          Performs a dilation operation (see 'imdilate').  BW can have
          any number of dimensions, and 'strel ("hypercube", ndims (BW),
          3)' is used as structuring element.

     'erode'
          Performs an erosion operation (see 'imerode').  BW can have
          any number of dimensions, and 'strel ("hypercube", ndims (BW),
          3)' is used as structuring element.

     'fill'
          Performs a interior fill operation.  Sets a pixel to 1 if all
          four-connected pixels are 1.  BW can have any number of
          dimensions in which case connectivity is '(2*ndims(BW))'.

     'hbreak'
          Performs a H-break operation.  Breaks (sets to 0) pixels that
          are H-connected.

     'majority'
          Performs a majority black operation.  Sets a pixel to 1 if the
          majority of the pixels (5 or more for a two dimensional image)
          in a 3-by-3 window is 1.  If not set to 0.  BW can have any
          number of dimensions in which case the window has dimensions
          'repmat (3, 1, ndims (BW))'.

     'open'
          Performs an opening operation, which is an erosion followed by
          a dilation (see 'imopen').  BW can have any number of
          dimensions, and 'strel ("hypercube", ndims (BW), 3)' is used
          as structuring element.

     'remove'
          Performs a iterior pixel remove operation.  Sets a pixel to 0
          if all of its four-connected neighbours are 1.  BW can have
          any number of dimensions in which case connectivity is
          '(2*ndims(BW))'.

     'shrink'
          Performs a shrink operation.  Sets pixels to 0 such that an
          object without holes erodes to a single pixel (set to 1) at or
          near its center of mass.  An object with holes erodes to a
          connected ring lying midway between each hole and its nearest
          outer boundary.  It preserves Euler number.

     'skel'
          Performs a skeletonization operation.  It calculates a "median
          axis skeleton" so that points of this skeleton are at the same
          distance of its nearby borders.  It preserver Euler number.
          Please read compatibility notes for more info.

          It uses the same algorithm as skel-pratt but this could change
          for compatibility in the future.

     'skel-lantuejoul'
          Performs a skeletonization operation as described in Gonzalez
          & Woods "Digital Image Processing" pp 538-540.  The text
          references Lantuejoul as author of this algorithm.

          It has the beauty of being a clean and simple approach, but
          skeletons are thicker than they need to and, in addition, not
          guaranteed to be connected.

          This algorithm is iterative.  It will be applied the minimum
          value of N times or number of iterations specified in
          algorithm description.  It's most useful to run this algorithm
          with 'n=Inf'.

          BW can have any number of dimensions.

     'skel-pratt'
          Performs a skeletonization operation as described by William
          K. Pratt in "Digital Image Processing".

     'spur'
          Performs a remove spur operation.  It sets pixel to 0 if it
          has only one eight-connected pixel in its neighbourhood.

     'thicken'
          Performs a thickening operation.  This operation "thickens"
          objects avoiding their fusion.  Its implemented as a thinning
          of the background.  That is, thinning on negated image.
          Finally a diagonal fill operation is performed to avoid
          "eight-connecting" objects.

     'thin'
          Performs a thinning operation.  When n=Inf, thinning sets
          pixels to 0 such that an object without holes is converted to
          a stroke equidistant from its nearest outer boundaries.  If
          the object has holes it creates a ring midway between each
          hole and its near outer boundary.  This differ from shrink in
          that shrink converts objects without holes to a single pixels
          and thin to a stroke.  It preserves Euler number.

     'tophat'
          Performs a top hat operation, a opening operation (which is an
          erosion followed by a dilation) and finally subtracts the
          original image (see 'imtophat').  BW can have any number of
          dimensions, and 'strel ("hypercube", ndims (BW), 3)' is used
          as structuring element.

     Some useful concepts to understand operators:

     Operations are defined on 3-by-3 blocks of data, where the pixel in
     the center of the block.  Those pixels are numerated as follows:

     X3   X2   X1
     X4   X    X0
     X5   X6   X7

     *Neighbourhood definitions used in operation descriptions:*
     ''four-connected''
          It refers to pixels which are connected horizontally or
          vertically to X: X1, X3, X5 and X7.
     ''eight-connected''
          It refers to all pixels which are connected to X: X0, X1, X2,
          X3, X4, X5, X6 and X7.

     *Compatibility notes:*
     ''skel''
          Algorithm used here is described in Pratt's book.  When
          applying it to the "circles" image in MATLAB documentation,
          results are not the same.  Perhaps MATLAB uses Blum's
          algorithm (for further info please read comments in code).
     ''skel-pratt''
          This option is not available in MATLAB.
     ''skel-lantuejoul''
          This option is not available in MATLAB.
     ''thicken''
          This implementation also thickens image borders.  This can
          easily be avoided i necessary.  MATLAB documentation doesn't
          state how it behaves.

     References: W. K. Pratt, "Digital Image Processing" Gonzalez and
     Woods, "Digital Image Processing"

     See also: imdilate, imerode, imtophat, imbothat, makelut, applylut.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Perform morphological operation on binary image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
bwperim


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 836
 -- Function File: bwperim (BW)
 -- Function File: bwperim (BW, CONN)
     Find perimeter of objects in binary images.

     Values from the matrix BW are considered part of an object
     perimeter if their value is non-zero and is connected to at least
     one zero-valued element, or to the outside of BW.

     Element connectivity CONN, to define the size of objects, can be
     specified with a numeric scalar (number of elements in the
     neighborhood):

     '4 or 8'
          for 2 dimensional matrices;
     '6, 18 or 26'
          for 3 dimensional matrices;

     or with a binary matrix representing a connectivity array.
     Defaults to 'conndef (ndims (BW), "minimal")' which is equivalent
     to CONN of 4 and 6 for 2 and 3 dimensional matrices respectively.

     See also: bwarea, bwboundaries, imerode, mmgrad.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Find perimeter of objects in binary images.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
bwpropfilt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1347
 -- Function File: bwpropfilt (BW, ATTRIB)
 -- Function File: bwpropfilt (BW, I, ATTRIB)
 -- Function File: bwpropfilt (..., RANGE)
 -- Function File: bwpropfilt (..., N)
 -- Function File: bwpropfilt (..., N, KEEP)
 -- Function File: bwpropfilt (..., ..., CONN)
     Filter objects from image based on their properties.

     Returns a logical matrix with the objects of BW filtered based on
     the specific property ATTRIB.  The possible values for ATTRIB are
     all the properties from 'regionprops' that return a scalar value,
     e.g., Area, Extent, and MaxIntensity, but not PixelValues, basic,
     and BoundingBox.  For certain attributes, such as MaxIntensity and
     WeightedCentroid, the grayscale image I must also be specified.

     To filter objects with a value on a specific interval, RANGE must
     be a two-element vector with the interval '[LOW HIGH]' (values are
     inclusive).

     Alternatively, a scalar N will select the objects with the N
     highest values.  The KEEP option defaults to "largest" but can also
     be set to "smallest" to select the N objects with lower values.

     The last optional argument, CONN, can be a connectivity matrix, or
     the number of elements connected to the center (see 'conndef').

     See also: bwareaopen, bwareafilt, bwlabel, bwlabeln, bwconncomp,
     regionprops.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Filter objects from image based on their properties.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
bwselect


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 431
 -- Function File: [IMOUT, IDX] = bwselect(IM, COLS, ROWS, CONNECT)
     Select connected regions in a binary image.

     'IM'
          binary input image
     '[COLS, ROWS]'
          vectors of starting points (x,y)
     'CONNECT'
          connectedness 4 or 8.  default is 8
     'IMOUT'
          the image of all objects in image im that overlap pixels in
          (cols,rows)
     'IDX'
          index of pixels in imout


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Select connected regions in a binary image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
checkerboard


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1087
 -- Function File: checkerboard ()
 -- Function File: checkerboard (SIDE)
 -- Function File: checkerboard (SIDE, SIZE)
 -- Function File: checkerboard (SIDE, M, N)
 -- Function File: checkerboard (SIDE, M, N, P, ...)
     Create checkerboard.

     The checkerboard is created by repeating a tile pattern and
     creating a block matrix of size SIZE, or MxN.  The tile pattern
     itself is made of four squares of SIDE pixels wide.  Note how the
     number of squares is twice of SIZE.

     The tile pattern is white on black on the right side, and grey on
     black on the left side of the matrix.

     At the simplest case, a 2 by 2 pattern with squares of 1 pixel
     side.

          checkerboard (1, [2 2])
          =>
             0.0   1.0   0.0   0.7
             1.0   0.0   0.7   0.0
             0.0   1.0   0.0   0.7
             1.0   0.0   0.7   0.0

     Defaults to 4x4 tiles 10 pixels wide.

     N-Dimensional checkerboards are supported with SIZE of any length
     or specifying dimension length arguments, i.e., M, N, P, ....

     See also: ndgrid, repmat.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
Create checkerboard.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
col2im


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2376
 -- Function File: col2im (B, BLOCK_SIZE, A_SIZE)
 -- Function File: col2im (B, BLOCK_SIZE, A_SIZE, BLOCK_TYPE)
     Rearrange block columns back into matrix.

     Rearranges columns of the matrix B, representing blocks of size
     BLOCK_SIZE from a matrix of size A_SIZE, back into its original
     size (usually close to A_SIZE.  This function is most useful as
     reverse operation to 'im2col'.

     Blocks are assumed to be from one of two types as defined by
     BLOCK_TYPE (defaults to "sliding"):

     "distinct"
          Each column of B is assumed to be distinct blocks, with no
          overlapping elements, of size BLOCK_SIZE, to rebuild a matrix
          of size A_SIZE.  Any padding that may have been required to
          form B from a matrix of A_SIZE, is removed accordingly.

     "sliding"
          This reshapes B into a matrix of size 'A_SIZE - BLOCK_SIZE
          +1'.  Sliding blocks are most useful to apply a sliding window
          filter with functions that act along columns.  In this
          situation, B is usually a row vector, so that if BLOCK_SIZE is
          [1 1], A_SIZE will be the size of the output matrix.  When
          converting a matrix into blocks with 'im2col', there will be
          less blocks to account to borders, so if BLOCK_SIZE is the
          same in both 'col2im' and 'im2col', A_SIZE can be the size out
          the output from 'im2col'.

     Blocks are assumed to have been from a matrix, the same direction
     elements are organized in an Octave matrix (top to bottom, then
     left to right), and the direction that blocks are taken in
     'im2col'.

          ## Get distinct blocks of size [2 3] from A into columns, and
          ## put them back together into the original position
          A = reshape (1:24, [4 6])
          B = im2col (A, [2 3], "distinct")
          col2im (B, [2 3], [4 6], "distinct")

          ## Get sliding blocks of size [2 3] from A into columns, calculate
          ## the mean of each block (mean of each column), and reconstruct A.
          ## This is the equivalent to a sliding window filter and ignoring
          ## borders.
          A = reshape (1:24, [4 6])
          B = im2col (A, [2 3], "sliding")
          C = mean (B);
          col2im (C, [1 1], [3 4], "sliding")

     See also: blockproc, bestblk, colfilt, im2col, nlfilter, reshape.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Rearrange block columns back into matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
colfilt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2969
 -- Function File: colfilt (A, BLOCK_SIZE, BLOCK_TYPE, FUNC)
 -- Function File: colfilt (A, BLOCK_SIZE, SUBSIZE, BLOCK_TYPE, FUNC,
          ...)
 -- Function File: colfilt (A, "indexed", ...)
 -- Function File: colfilt (..., FUNC, EXTRA_ARGS, ...)
     Apply function to matrix blocks

     Executes the function FUNC on blocks of size BLOCK_SIZE, taken from
     the matrix A.  Both the matrix A, and the block can have any number
     of dimensions.

     The different blocks are organized into a matrix, each block as a
     single column, and passed as the first to the function handle FUNC.
     Any input arguments to 'colfilt' after FUNC are passed to FUNC
     after the blocks matrix.

     Blocks can be of two different types as defined by the string
     BLOCK_TYPE:

     "distinct"
          Each block is completely distinct from the other, with no
          overlapping elements.  FUNC must return a matrix of exactly
          the same size as its input.

     "sliding"
          Each possible block of size BLOCK_SIZE inside A is used.  FUNC
          should act along the column dimension (be a column compression
          function) and return a vector of length equal to the number of
          columns of its input.

     The optional argument SUBSIZE divides A into smaller pieces before
     generating the matrices with one block per column in order to save
     memory.  It is currently only accepted for MATLAB compatibility.

     If A is an indexed image, the second argument should be the string
     "indexed" so that any required padding is done correctly.  The
     padding value will be 0 except for indexed images of class uint8
     and uint16.

     This function is mostly useful to apply moving or sliding window
     filter when BLOCK_TYPE is "sliding".  However, for many cases,
     specialized functions perform much faster.  For the following
     common cases, consider the suggested alternatives;

     moving average
          A moving average filter is equivalent to convolve with a
          matrix of '1/N' sized BLOCK_SIZE, where N is the total number
          of elements in a block.  Use 'convn (A, (1/N) * ones
          (BLOCK_SIZE) *, "same")'

     maximum or minimum
          This is the equivalent to a dilation and erosion.  Use
          'imdilate' or 'imerode'.

     any or all
          Same as dilation and erosion but with logical input.  Use
          'imdilate' or 'imerode' with 'logical (A)'.

     median
          Use 'medfilt2' if A is only 2 dimensional, and 'ordfiltn' with
          the 'floor (prod (N/ 2)' th element, where N is the total
          number of elements in a block (add 1 if it is an even number).

     sort or nth_element
          Use 'ordfiltn'.

     standard deviation
          Use 'stdfilt'.

     sum
          Use a matrix of 1 to perform convolution, 'convn (A, ones
          (BLOCK_SIZE), "same")'

     See also: bestblk, blockproc, col2im, im2col, nlfilter.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Apply function to matrix blocks



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
colorgradient


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 540
 -- Function File: M = colorgradient (C, W, N)
     Define a colour map which smoothly traverses the given colors.  C
     contains the colours, one row per r,g,b value.  W(i) is the
     relative length of the transition from colour i to colour i+1 in
     the entire gradient.  The default is ones(rows(C)-1,1).  n is the
     length of the colour map.  The default is rows(colormap).

     E.g.,
          colorgradient([0,0,1; 1,1,0; 1,0,0])  # blue -> yellow -> red
          x = linspace(0,1,200);
          imagesc(x(:,ones(30,1)))';


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Define a colour map which smoothly traverses the given colors.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
corr2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 202
 -- Function File: R = corr2 (I,J)
     Compute correlation coefficients of images.

     The two images I and J must be real type matrices or vectors of
     same size.

     See also: corr, cov, std2.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Compute correlation coefficients of images.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
cp2tform


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3465
 -- Function File: T = cp2tform (IN_CP, OUT_CP, TTYPE)
 -- Function File: T = cp2tform (..., OPT)
     Return a transformation structure T (see "help maketform" for the
     form of the structure) that can be further used to transform
     coordinates between an input space and an ouput space.

     The transform is inferred from two n-by-2 arrays, IN_CP and OUT_CP,
     which contain the coordinates of n control points in the two 2D
     spaces.  Transform coefficients are stored in T.tdata.
     Interpretation of transform coefficients depends on the requested
     transform type TTYPE:

     "affine"
          Return both forward (input space to output space) and inverse
          transform coefficients T.tdata.T and T.tdata.Tinv.  Transform
          coefficients are 3x2 matrices which can be used as follows:

               IN_CP = [OUT_CP ones(rows (out_cp,1))] * Tinv
               OUT_CP = [IN_CP ones(rows (in_cp,1))] * T
          This transformation is well suited when parallel lines in one
          space are still parallel in the other space (e.g.  shear,
          translation, ...).

     "nonreflective similarity"
          Same as "affine" except that the transform matrices T and Tinv
          have the form
               Tcoefs = [a -b;
                         b  a;
                         c  d]
          This transformation may represent rotation, scaling and
          translation.  Reflection is not included.

     "similarity"
          Same as "nonreflective similarity" except that the transform
          matrices T and Tinv may also have the form
               Tcoefs = [a  b;
                         b -a;
                         c  d]
          This transformation may represent reflection, rotation,
          scaling and translation.  Generates a warning if the
          nonreflective similarity is better suited.

     "projective"
          Return both forward (input space to output space) and inverse
          transform coefficients T.tdata.T and T.tdata.Tinv.  Transform
          coefficients are 3x3 matrices which can be used as follows:

               [u v w] = [OUT_CP ones(rows (out_cp,1))] * Tinv
               IN_CP = [u./w, v./w];
               [x y z] = [IN_CP ones(rows (in_cp,1))] * T
               OUT_CP = [x./z y./z];
          This transformation is well suited when parallel lines in one
          space all converge toward a vanishing point in the other
          space.

     "polynomial"
          Here the OPT input argument is the order of the polynomial
          fit.  OPT must be 2, 3 or 4 and input control points number
          must be respectively at least 6, 10 or 15.  Only the inverse
          transform (output space to input space) is included in the
          structure T.  Denoting x and y the output space coordinate
          vector and u, v the the input space coordinates.  Inverse
          transform coefficients are stored in a (6,10 or 15)-by-2
          matrix which can be used as follows:

               Second order:
               [u v] = [1 x y x*y x^2 y^2] * Tinv
               Third order:
               [u v] = [1 x y x*y x^2 y^2 y*x^2 x*y^2 x^3 y^3] * Tinv
               Fourth order:
               [u v] = [1 x y x*y x^2 y^2 y*x^2 x*y^2 x^3 y^3 x^3*y x^2*y^2 x*y^3 x^4 y^4] * Tinv
          This transform is well suited when lines in one space become
          curves in the other space.

     See also: tformfwd, tforminv, maketform.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Return a transformation structure T (see "help maketform" for the form
of the st



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
edge


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4820
 -- Function File: [BW, THRESH] = edge (IM, METHOD, ...)
     Find edges using various methods.

     The image IM must be 2 dimensional and grayscale.  The METHOD must
     be a string with the string name.  The other input arguments are
     dependent on METHOD.

     BW is a binary image with the identified edges.  THRESH is the
     threshold value used to identify those edges.  Note that THRESH is
     used on a filtered image and not directly on IM.

     See also: fspecial.

 -- Function File: edge (IM, "Canny")
 -- Function File: edge (IM, "Canny", THRESH)
 -- Function File: edge (IM, "Canny", THRESH, SIGMA)
     Find edges using the Canny method.

     THRESH is two element vector for the hysteresis thresholding.  The
     lower and higher threshold values are the first and second elements
     respectively.  If it is a scalar value, the lower value is set to
     '0.4 * THRESH'.

     SIGMA is the standard deviation to be used on the Gaussian filter
     that is used to smooth the input image prior to estimating
     gradients.  Defaults to 'sqrt (2)'.

 -- Function File: edge (IM, "Kirsch")
 -- Function File: edge (IM, "Kirsch", THRESH)
 -- Function File: edge (IM, "Kirsch", THRESH, DIRECTION)
 -- Function File: edge (IM, "Kirsch", THRESH, DIRECTION, THINNING)
     Find edges using the Kirsch approximation to the derivatives.

     Edge points are defined as points where the length of the gradient
     exceeds a threshold THRESH.

     THRESH is the threshold used and defaults to twice the square root
     of the mean of the gradient squared of IM.

     DIRECTION is the direction of which the gradient is approximated
     and can be "vertical", "horizontal", or "both" (default).

     THINNING can be the string "thinning" (default) or "nothinning".
     This controls if a simple thinning procedure is applied to the edge
     image such that edge points also need to have a larger gradient
     than their neighbours.  The resulting "thinned" edges are only one
     pixel wide.

 -- Function File: edge (IM, "Lindeberg")
 -- Function File: edge (IM, "Lindeberg", SIGMA)
     Find edges using the the differential geometric single-scale edge
     detector by Tony Lindeberg.

     SIGMA is the scale (spread of Gaussian filter) at which the edges
     are computed.  Defaults to '2'.

     This method does not use a threshold value and therefore does not
     return one.

 -- Function File: edge (IM, "LoG")
 -- Function File: edge (IM, "LoG", THRESH, SIGMA)
     Find edges by convolving with the Laplacian of Gaussian (LoG)
     filter, and finding zero crossings.

     Only zero crossings where the filter response is larger than THRESH
     are retained.  THRESH is automatically computed as 0.75*M, where M
     is the mean of absolute value of LoG filter response.

     SIGMA sets the spread of the LoG filter.  Default to '2'.

 -- Function File: edge (IM, "Prewitt", ...)
     Find edges using the Prewitt approximation to the derivatives.

     This method is the same as Kirsch except a different approximation
     gradient is used.

 -- Function File: edge (IM, "Roberts")
 -- Function File: edge (IM, "Roberts", THRESH)
 -- Function File: edge (IM, "Roberts", THRESH, THINNING)
     Find edges using the Roberts approximation to the derivatives.

     This method is similar to Kirsch except a different approximation
     gradient is used, and the default THRESH is multiplied by
     sqrt(1.5).  In addition, there it does not accept the DIRECTION
     argument.

 -- Function File: edge (IM, "Sobel", ...)
     Find edges using the Sobel approximation to the derivatives.

     This method is the same as Kirsch except a different approximation
     gradient is used.

 -- Function File: edge (IM, "zerocross", THRESH, FILTER)
     Find edges by convolving with a user-supplied filter and finding
     zero crossings.

 -- Function File: edge (IM, "Andy", THRESH, PARAMS)
     Find edges by the original (Andy Adlers) 'edge' algorithm.  The
     steps are
       1. Do a Sobel edge detection and to generate an image at a high
          and low threshold.
       2. Edge extend all edges in the LT image by several pixels, in
          the vertical, horizontal, and 45 degree directions.  Combine
          these into edge extended (EE) image.
       3. Dilate the EE image by 1 step.
       4. Select all EE features that are connected to features in the
          HT image.

     The parameters for the method is given in a vector:
     params(1)==0 or 4 or 8
          Perform x connected dilatation (step 3).
     params(2)
          Dilatation coefficient (threshold) in step 3.
     params(3)
          Length of edge extention convolution (step 2).
     params(4)
          Coefficient of extention convolution in step 2.
     defaults = [8, 1, 3, 3]


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Find edges using various methods.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
edgetaper


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 203
 -- Function File: edgetaper (IMG, PSF)
     Blur border (edges) of image to prevent ringing artifacts.

     _Warning_: this function is not MATLAB compatible and is likely to
     change in the future.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Blur border (edges) of image to prevent ringing artifacts.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
entropy


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 582
 -- Function File: E = entropy (IM)
 -- Function File: E = entropy (IM, NBINS)
     Computes the entropy of an image.

     The entropy of the elements of the image IM is computed as

          E = -sum (P .* log2 (P)

     where P is the distribution of the elements of IM.  The
     distribution is approximated using a histogram with NBINS cells.
     If IM is 'logical' then two cells are used by default.  For other
     classes 256 cells are used by default.

     When the entropy is computed, zero-valued cells of the histogram
     are ignored.

     See also: entropyfilt.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Computes the entropy of an image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
entropyfilt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1198
 -- Function File: E = entropyfilt (IM)
 -- Function File: E = entropyfilt (IM, DOMAIN)
 -- Function File: E = entropyfilt (IM, DOMAIN, PADDING, ...)
     Computes the local entropy in a neighbourhood around each pixel in
     an image.

     The entropy of the elements of the neighbourhood is computed as

          E = -sum (P .* log2 (P)

     where P is the distribution of the elements of IM.  The
     distribution is approximated using a histogram with NBINS cells.
     If IM is 'logical' then two cells are used.  For other classes 256
     cells are used.

     When the entropy is computed, zero-valued cells of the histogram
     are ignored.

     The neighbourhood is defined by the DOMAIN binary mask.  Elements
     of the mask with a non-zero value are considered part of the
     neighbourhood.  By default a 9 by 9 matrix containing only non-zero
     values is used.

     At the border of the image, extrapolation is used.  By default
     symmetric extrapolation is used, but any method supported by the
     'padarray' function can be used.  Since extrapolation is used, one
     can expect a lower entropy near the image border.

     See also: entropy, paddarray, stdfilt.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 76
Computes the local entropy in a neighbourhood around each pixel in an
image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
fchcode


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 777
 -- Function File: FCC = fchcode (BOUND)
     Determine the Freeman chain code for a boundary.

     'fchcode' computes the Freeman chain code for the N-connected
     boundary BOUND.  N must be either 8 or 4.

     BOUND is a K-by-2 matrix containing the row/column coordinates of
     points on the boundary.  Optionally, the first point can be
     repeated as the last point, resulting in a (K+1)-by-2 matrix.

     FCC is a structure containing the following elements.

           x0y0   = Row/column coordinates where the code starts (1-by-2)
           fcc    = Freeman chain code (1-by-K)
           diff   = First difference of fcc (1-by-K)

     The code uses the following directions.

           3 2 1
           4 . 0
           5 6 7

     See also: bwboundaries.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Determine the Freeman chain code for a boundary.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
fftconv2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 399
 -- Function File: fftconv2 (A, B)
 -- Function File: fftconv2 (V1, V2, A)
 -- Function File: fftconv2 (..., SHAPE)
     Convolve 2 dimensional signals using the FFT.

     This method is faster but less accurate than CONV2 for large A and
     B.  It also uses more memory.  A small complex component will be
     introduced even if both A and B are real.

     See also: conv2, fftconv, fft, ifft.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Convolve 2 dimensional signals using the FFT.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
fftconvn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2550
 -- Function File: fftconvn (A, B)
 -- Function File: fftconvn (A, B, SHAPE)
     Convolve N dimensional signals using the FFT for computation.

     This function is equivalent to 'convn' but using the FFT. It
     convolves the two N dimensional A and B.  The size of output is
     controlled by the option SHAPE which removes the borders where
     boundary effects may be seen:

     "full" (default)
          Return the full convolution.

     "same"
          Return central part of the convolution with the same size as
          A.

     "valid"
          Return only the parts which do not include zero-padded edges.

     Using the FFT may be faster but this is not always the case and can
     be a lot worse, specially for smalls A and B.  This performance
     increase also comes at the cost of increased memory usage, as well
     as a loss of precision.

          a = randi (255, 1024, 1024);
          b = randi (255, 10, 10);
          t = cputime (); convn (a, b); cputime () -t
             => 0.096000
          t = cputime (); fftconvn (a, b); cputime () -t
             => 1.2560

          b = randi (255, 50, 50);
          t = cputime (); convn (a, b); cputime () -t
             => 2.3400
          t = cputime (); fftconvn (a, b); cputime () -t
             => 1.2560

     Note how computation time for 'convn' increased with the size of B
     but remained constant when using 'fftconvn'.  When performing the
     convolution, 'fftconvn' zero pads both A and B so their lengths are
     a power of two on all dimensions.  This may further increase memory
     usage but will also increase performance.  In this example, the
     computation time will remain constant until 'size (A) + size (B)
     -1' is greater than 2048 after which it will remain constant again
     until it reaches 4096.

          a = randi (255, 1024, 1024);
          b = randi (255, 50, 50);
          t = cputime (); fftconvn (a, b); cputime () -t
             => 1.2760
          a = randi (255, 2048-50+1, 2048-50+1);
          t = cputime (); fftconvn (a, b); cputime () -t
             => 1.2120
          a = randi (255, 2049-50+1, 2049-50+1);
          t = cputime (); fftconvn (a, b); cputime () -t
             => 6.1520
          a = randi (255, 4096-50+1, 4096-50+1);
          t = cputime (); fftconvn (a, b); cputime () -t
             => 6.2360
          a = randi (255, 4097-50+1, 4097-50+1);
          t = cputime (); fftconvn (a, b); cputime () -t
             => 38.120

     See also: convn, fftconv2, fftconv, padarray.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Convolve N dimensional signals using the FFT for computation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
findbounds


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 596
 -- Function File: OUTBND = findbounds (T, INBND)
     Estimate bounds for spatial transformation.

     Given a transformation structure T (see e.g.  maketform) and bounds
     INBND (2-by-ndims_in) in an input space, returns an estimation of
     the bounds in the output space OUTBND (2-by-ndims_out).  For
     instance two dimensionnal bounds could be represented as : [xmin
     ymin; xmax ymax].  If T does not define a forward transform (i.e.
     for 'polynomial'), the output bounds are infered using fsolve and
     the inverse transform.

     See also: maketform, cp2tform, tformfwd.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Estimate bounds for spatial transformation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
fspecial


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3988
 -- Function File: fspecial (TYPE, ...)
     Create spatial filters for image processing.

     TYPE is a string specifying the filter name.  The input arguments
     that follow are type specific.  The return value is a correlation
     kernel, often to be used by 'imfilter'.

     See also: conv2, convn, filter2, imfilter.

 -- Function File: fspecial ("average")
 -- Function File: fspecial ("average", LENGTHS)
     Rectangular averaging filter.

     The optional argument LENGTHS controls the size of the filter.  If
     LENGTHS is an integer N, a N by N filter is created.  If it is a
     two-vector with elements N and M, the resulting filter will be N by
     M.  By default a 3 by 3 filter is created.

 -- Function File: fspecial ("disk")
 -- Function File: fspecial ("disk", RADIUS)
     Circular averaging filter.

     The optional argument RADIUS controls the radius of the filter.  If
     RADIUS is an integer R, a 2 R + 1 filter is created.  By default a
     radius of 5 is used.  If the returned matrix corresponds to a
     Cartesian grid, each element of the matrix is weighted by how much
     of the corresponding grid square is covered by a disk of radius R
     and centred at the middle of the element R+1,R+1.

 -- Function File: fspecial ("gaussian")
 -- Function File: fspecial ("gaussian", LENGTHS)
 -- Function File: fspecial ("gaussian", LENGTHS, SIGMA)
     Create Gaussian filter.

     Returns a N dimensional Gaussian distribution with standard
     deviation SIGMA and centred in an array of size LENGTHS.

     LENGTHS defaults to '[3 3]' and SIGMA to 0.5.  If LENGTHS is a
     scalar, it returns a square matrix of side LENGTHS, .i.e., its
     value defines both the number of rows and columns.

 -- Function File: fspecial ("log")
 -- Function File: fspecial ("log", LENGTHS)
 -- Function File: fspecial ("log", LENGTHS, STD)
     Laplacian of Gaussian.

     The optional argument LENGTHS controls the size of the filter.  If
     LENGTHS is an integer N, a N by N filter is created.  If it is a
     two-vector with elements N and M, the resulting filter will be N by
     M.  By default a 5 by 5 filter is created.  The optional argument
     STD sets spread of the filter.  By default a spread of 0.5 is used.

 -- Function File: fspecial ("laplacian")
 -- Function File: fspecial ("laplacian", ALPHA)
     3x3 approximation of the laplacian.

     The filter is approximated as

          (4/(ALPHA+1)) * [   ALPHA/4   (1-ALPHA)/4     ALPHA/4
                           (1-ALPHA)/4   -1          (1-ALPHA)/4
                              ALPHA/4   (1-ALPHA)/4     ALPHA/4 ];

     where ALPHA is a number between 0 and 1.  By default it is 0.2.

 -- Function File: fspecial ("unsharp")
 -- Function File: fspecial ("unsharp", ALPHA)
     Sharpening filter.

     The following filter is returned
          (1/(ALPHA+1)) * [-ALPHA   ALPHA-1 -ALPHA
                            ALPHA-1 ALPHA+5  ALPHA-1
                           -ALPHA   ALPHA-1 -ALPHA];

     where ALPHA is a number between 0 and 1.  By default it is 0.2.

 -- Function File: fspecial ("motion")
 -- Function File: fspecial ("motion", LENGTHS)
 -- Function File: fspecial ("motion", LENGTHS, ANGLE)
     Motion blur filter of width 1 pixel.

     The optional input argument LENGTHS controls the length of the
     filter, which by default is 9.  The argument ANGLE controls the
     angle of the filter, which by default is 0 degrees.

 -- Function File: fspecial ("sobel")
     Horizontal Sobel edge filter.

     The following filter is returned

          [ 1  2  1
            0  0  0
           -1 -2 -1 ]

 -- Function File: fspecial ("prewitt")
     Horizontal Prewitt edge filter.

     The following filter is returned

          [ 1  1  1
            0  0  0
           -1 -1 -1 ]

 -- Function File: fspecial ("kirsch")
     Horizontal Kirsch edge filter.

     The following filter is returned

          [ 3  3  3
            3  0  3
           -5 -5 -5 ]


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Create spatial filters for image processing.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
getrangefromclass


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 925
 -- Function File: RANGE = getrangefromclass (IMG)
     Return display range of image.

     For a given image IMG, returns the 1x2 element matrix RANGE with
     the display range (minimum and maximum display values) for an image
     of that class.

     Images of different classes have different display ranges, the
     ranges of values that Octave will interpret between black to white.
     For an integer image, the range is from 'intmin' to 'intmax' of
     that class; for images of class logical, single, or double, the
     range is [0 1].

     Note that RANGE will be of class double, independently of the class
     of IMG.

          getrangefromclass (ones (5)) # note that class is 'double'
               => [0   1]
          getrangefromclass (logical (ones (5)))
               => [0   1]
          getrangefromclass (int8 (ones (5)))
               => [-128  127]

     See also: intmin, intmax, bitmax.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Return display range of image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
grayslice


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 875
 -- Function File: grayslice (I)
 -- Function File: grayslice (I, N)
 -- Function File: grayslice (I, V)
     Create indexed image from intensity image using multilevel
     thresholding.

     The intensity image I will be split into multiple threshold levels.
     For regularly spaced intervals, the number of levels can be
     specified as the numeric scalar N (defaults to 10), which will use
     the intervals:

     1  2       n-1
     -, -, ..., ---
     n  n        n

     For irregularly spaced intervals, the numeric vector V can be
     specified instead.  The values in V must be in the range [0 1]
     independently of the class of I.  These will be adjusted by
     'grayslice' according to the image.

     The output image will be of class uint8 if the number of levels is
     less than 256, otherwise it will be double.

     See also: im2bw, gray2ind.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 72
Create indexed image from intensity image using multilevel thresholding.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
graythresh


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5384
 -- Function File: [LEVEL, SEP] = graythresh (IMG)
 -- Function File: [LEVEL, SEP] = graythresh (IMG, METHOD, OPTIONS)
 -- Function File: [LEVEL, SEP] = graythresh (HIST, ...)
     Compute global image threshold.

     Given an image IMG finds the optimal threshold value LEVEL for
     conversion to a binary image with 'im2bw'.  Color images are
     converted to grayscale before LEVEL is computed.  An image
     histogram HIST can also be used to allow for preprocessing of the
     histogram.

     The optional argument METHOD is the algorithm to be used (default's
     to Otsu).  Some methods may have other OPTIONS and/or return an
     extra value SEP (see each entry for details).  The available
     METHODs are:

     Otsu (default)
          Implements Otsu's method as described in 'Nobuyuki Otsu
          (1979). "A threshold selection method from gray-level
          histograms", IEEE Trans. Sys., Man., Cyber. 9 (1): 62-66'.
          This algorithm chooses the threshold to minimize the
          intraclass variance of the black and white pixels.

          The second output, SEP represents the "goodness" (or
          separability) of the threshold at LEVEL.  It is a value within
          the range [0 1], the lower bound (zero) being attainable by,
          and only by, histograms having a single constant gray level,
          and the upper bound being attainable by, and only by,
          two-valued pictures.

     concavity
          Find a global threshold for a grayscale image by choosing the
          threshold to be in the shoulder of the histogram 'A.
          Rosenfeld, and P. De La Torre (1983). "Histogram concavity
          analysis as an aid in threshold selection", IEEE Transactions
          on Systems, Man, and Cybernetics, 13: 231-235'.

     intermodes
          This assumes a bimodal histogram and chooses the threshold to
          be the mean of the two peaks of the bimodal histogram 'J. M.
          S. Prewitt, and M. L. Mendelsohn (1966). "The analysis of cell
          images", Annals of the New York Academy of Sciences, 128:
          1035-1053'.

          Images with histograms having extremely unequal peaks or a
          broad and flat valley are unsuitable for this method.

     intermeans
          Iterative procedure based on the iterative intermeans
          algorithm of 'T. Ridler, and S. Calvard (1978). "Picture
          thresholding using an iterative selection method", IEEE
          Transactions on Systems, Man, and Cybernetics, 8: 630-632' and
          'H. J. Trussell (1979). "Comments on 'Picture thresholding
          using an iterative selection method'", IEEE Transactions on
          Systems, Man, and Cybernetics, 9: 311'.

          Note that several implementations of this method exist.  See
          the source code for details.

     MaxEntropy
          Implements Kapur-Sahoo-Wong (Maximum Entropy) thresholding
          method based on the entropy of the image histogram 'J. N.
          Kapur, P. K. Sahoo, and A. C. K. Wong (1985). "A new method
          for gray-level picture thresholding using the entropy of the
          histogram", Graphical Models and Image Processing, 29(3):
          273-285'.

     MaxLikelihood
          Find a global threshold for a grayscale image using the
          maximum likelihood via expectation maximization method 'A. P.
          Dempster, N. M. Laird, and D. B. Rubin (1977). "Maximum
          likelihood from incomplete data via the EM algorithm", Journal
          of the Royal Statistical Society, Series B, 39:1-38'.

     mean
          The mean intensity value.  It is mostly used by other methods
          as a first guess threshold.

     MinError
          An iterative implementation of Kittler and Illingworth's
          Minimum Error thresholding 'J. Kittler, and J. Illingworth
          (1986). "Minimum error thresholding", Pattern recognition, 19:
          41-47'.

          This implementation seems to converge more often than the
          original.  Nevertheless, sometimes the algorithm does not
          converge to a solution.  In that case a warning is displayed
          and defaults to the initial estimate of the mean method.

     minimum
          This assumes a bimodal histogram and chooses the threshold to
          be in the valley of the bimodal histogram.  This method is
          also known as the mode method 'J. M. S. Prewitt, and M. L.
          Mendelsohn (1966). "The analysis of cell images", Annals of
          the New York Academy of Sciences, 128: 1035-1053'.

          Images with histograms having extremely unequal peaks or a
          broad and flat valley are unsuitable for this method.

     moments
          Find a global threshold for a grayscale image using moment
          preserving thresholding method 'W. Tsai (1985).
          "Moment-preserving thresholding: a new approach", Computer
          Vision, Graphics, and Image Processing, 29: 377-393'

     percentile
          Assumes a specific fraction of pixels (set at OPTIONS) to be
          background.  If no value is given, assumes 0.5 (equal
          distribution of background and foreground) 'W Doyle (1962).
          "Operation useful for similarity-invariant pattern
          recognition", Journal of the Association for Computing
          Machinery 9: 259-267'

     See also: im2bw.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Compute global image threshold.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
histeq


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 461
 -- Function File: J = histeq (I, N)
     Equalize histogram of grayscale image.

     The histogram contains N bins, which defaults to 64.

     I: Image in double format, with values from 0.0 to 1.0.

     J: Returned image, in double format as well.

     Note that the algorithm used for histogram equalization gives
     results qualitatively comparable but numerically different from
     MATLAB implementation.

     See also: imhist, mat2gray, brighten.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 38
Equalize histogram of grayscale image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
hough


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1096
 -- Function File: [H, THETA, RHO] = hough (BW)
 -- Function File: [H, THETA, RHO] = hough (BW, PROPERTY, VALUE, ...)
     Compute the Hough transform to find lines in a binary image.

     The resulting Hough transform matrix H (accumulator array) is 2D.
     Its rows correspond to the distance values RHO and its columns to
     the angle values THETA.  Points of high value in H correspond to
     present lines in the given image.

     The distance RHO is measured with respect to the image origin.  The
     angle THETA is measured clockwise to the vertical axis.

     The following PROPERTY values are possible:

     "Theta"
          A vector of angle values.  The Hough transform will be
          calculated at those Theta angle values.  The angles are given
          in degrees.  Defaults to [-90:89].

     "ThetaResolution"
          A scalar value to specify the Theta angles for the Hough
          transform in a different way.  This will result in Theta =
          [-90:ThetaResolution:90], with the +90° angle excluded.

     See also: hough_line, hough_circle, immaximas.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Compute the Hough transform to find lines in a binary image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
hough_circle


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 774
 -- Function File: ACCUM= hough_circle (BW, R)
     Perform the Hough transform for circles with radius R on the
     black-and-white image BW.

     As an example, the following shows how to compute the Hough
     transform for circles with radius 3 or 7 in the image IM
          bw = edge(im);
          accum = hough_circle(bw, [3, 7]);
     If IM is an NxM image ACCUM will be an NxMx2 array, where
     ACCUM(:,:,1) will contain the Hough transform for circles with
     radius 3, and ACCUM(:,:,2) for radius 7.  To find good circles you
     now need to find local maximas in ACCUM, which can be a hard
     problem.  If you find a local maxima in ACCUM(row, col, 1) it means
     that a good circle exists with center (row,col) and radius 3.

     See also: houghtf.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Perform the Hough transform for circles with radius R on the
black-and-white ima



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
houghtf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2210
 -- Function File: H = houghtf (BW)
 -- Function File: H = houghtf (BW, METHOD)
 -- Function File: H = houghtf (BW, METHOD, ARG)
     Perform the Hough transform for lines or circles.

     The METHOD argument chooses between the Hough transform for lines
     and circles.  It can be either "line" (default) or "circle".

     *Line Detection*

     If METHOD is "line", the function will compute the Hough transform
     for lines.  A line is parametrised in R and THETA as
          R = x*cos(THETA) + y*sin(THETA),
     where R is distance between the line and the origin, while THETA is
     the angle of the vector from the origin to this closest point.  The
     result H is an N by M matrix containing the Hough transform.  Here,
     N is the number different values of R that has been attempted.
     This is computed as '2*diag_length - 1', where 'diag_length' is the
     length of the diagonal of the input image.  M is the number of
     different values of THETA.  These can be set through the third
     input argument ARG.  This must be a vector of real numbers, and is
     by default 'pi*(-90:90)/180'.

     *Circle Detection*

     If METHOD is "circle" the function will compute the Hough transform
     for circles.  The circles are parametrised in R which denotes the
     radius of the circle.  The third input argument ARG must be a real
     vector containing the possible values of R.  If the input image is
     N by M, then the result H will be an N by M by K array, where K
     denotes the number of different values of R.

     As an example, the following shows how to compute the Hough
     transform for circles with radius 3 or 7 in the image IM
          bw = edge(im);
          H = houghtf(bw, "circle", [3, 7]);
     Here H will be an NxMx2 array, where H(:,:,1) will contain the
     Hough transform for circles with radius 3, and H(:,:,2) for radius
     7.  To find good circles you now need to find local maximas in H.
     If you find a local maxima in H(row, col, 1) it means that a good
     circle exists with center (row,col) and radius 3.  One way to
     locate maximas is to use the 'immaximas' function.

     See also: hough_line, hough_circle, immaximas.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Perform the Hough transform for lines or circles.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
im2bw


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1066
 -- Function File: im2bw (IMG)
 -- Function File: im2bw (X, CMAP)
 -- Function File: im2bw (..., THRESHOLD)
 -- Function File: im2bw (..., METHOD)
     Convert image to binary, black and white, by threshold.

     The input image IMG can either be a grayscale or RGB image.  In the
     later case, IMG is first converted to grayscale with 'rgb2gray'.
     Input can also be an indexed image X in which case the colormap
     CMAP needs to be specified.

     The value of THRESHOLD should be in the range [0,1] independently
     of the class of IMG.  Values from other classes can be converted to
     the correct value with 'im2double':

          bw = im2bw (img_of_class_uint8, im2double (thresh_of_uint8_class));

     For an automatic threshold value, consider using 'graythresh'.  The
     argument METHOD is a string that specifies a valid algorithm
     available in 'graythresh'.  The following are equivalent:

          bw = im2bw (img, "moments");
          bw = im2bw (img, graythresh (img, "moments"));

     See also: graythresh, ind2gray, rgb2gray.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Convert image to binary, black and white, by threshold.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
im2col


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2261
 -- Function File: im2col (A, BLOCK_SIZE)
 -- Function File: im2col (A, BLOCK_SIZE, BLOCK_TYPE)
 -- Function File: im2col (A, "indexed", ...)
     Rearrange blocks from matrix into columns.

     Rearranges blocks of size BLOCK_SIZE, sampled from the matrix A,
     into a serie of columns.  This effectively transforms any image
     into a 2 dimensional matrix, a block per column, which can then be
     passed to other functions that perform calculations along columns.

     Both blocks and matrix A can have any number of dimensions (though
     for sliding blocks, a block can't be larger than A in any
     dimension).  Blocks are always accessed in column-major order (like
     Octave arrays are stored) so that a matrix can be easily
     reconstructed with 'reshape' and 'col2im'.  For a 2 dimensional
     matrix, blocks are taken first from the top to the bottom, and then
     from the left to the right of the matrix.

     The sampling can be performed in two different ways as defined by
     BLOCK_TYPE (defaults to "sliding"):

     "distinct"
          Each block is completely distinct from the other, with no
          overlapping elements.  The matrix A is padded as required with
          a value of 0 (or 1 for non-integer indexed images).

     "sliding"
          A single block slides across A without any padding.

          While this can be used to perform sliding window operations
          such as maximum and median filters, specialized functions such
          as 'imdilate' and 'medfilt2' will be more efficient.

          Note that large images being arranged in large blocks can
          easily exceed the maximum matrix size (see 'sizemax').  For
          example, a matrix A of size 500x500, with sliding block of
          size [100 100], would require a matrix with 2.4108e+09
          elements, i.e., the number of elements in a block, '100*100',
          times the number of blocks, '(500-10+1) * (500-10+1)'.

     If A is an indexed image, the second argument should be the string
     "indexed" so that any required padding is done correctly.  The
     padding value will be 0 except for indexed images of class uint8
     and uint16.

     See also: blockproc, bestblk, col2im, colfilt, nlfilter, reshape.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Rearrange blocks from matrix into columns.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
im2int16


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 724
 -- Function File: im2int16 (IMG)
     Convert image to int16.

     The conversion of IMG to a 16-bit signed integer, is dependent on
     the type of input image.  The following input classes are
     supported:

     'uint8 or uint16'
          Values are rescaled to the range of the int16 class [-32768
          32767].

     'logical'
          True and false values are assigned a value of 32767 and -32768
          respectively.

     'double or single'
          Values are truncated to the interval [0 1] and then rescaled
          to the range of values of the int16 class [-32768 32767].

     'int16'
          Returns the same image.

     See also: im2bw, imcast, im2uint8, im2double, im2single, im2uint16.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Convert image to int16.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
im2single


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1001
 -- Function File: im2single (IMG)
 -- Function File: im2single (IMG, "indexed")
     Convert image to single precision.

     The conversion of IMG to single precision, is dependent on the type
     of input image.  The following input classes are supported:

     'uint8, uint16, and int16'
          The whole range of values from the class (see
          'getrangefromclass') are scaled for the interval [0 1], e.g.,
          if input image was uint8, intensity values of 0, 127, and 255,
          are converted to intensity of 0, 0.498, and 1.

     'logical'
          True and false values are assigned a value of 0 and 1
          respectively.

     'double'
          Values are cast to double precision.

     'single'
          Returns the same image.

     If the second argument is the string "indexed", then values are
     cast to single precision, and a +1 offset is applied if input is an
     integer class.

     See also: im2bw, imcast, im2uint8, im2double, im2int16, im2uint16.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Convert image to single precision.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
im2uint16


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1077
 -- Function File: im2uint16 (IMG)
 -- Function File: im2uint16 (IMG, "indexed")
     Convert image to uint16.

     The conversion of IMG to a 16-bit unsigned integer, is dependent on
     the type of input image.  The following input classes are supported
     for non-indexed images:

     'int16 or uint8'
          Values are rescaled to the range of the uint16 class [0
          65535].

     'logical'
          True and false values are assigned a value of 0 and 255
          respectively.

     'double or single'
          Values are truncated to the interval [0 1] and then rescaled
          to the range of values of the int16 class [0 255].

     'uint16'
          Returns the same image.

     If the second argument is the string "indexed", then values are
     cast to uint16, and a -1 offset is applied if input is a floating
     point class.  Input checking is performed and an error will be
     throw is the range of values in uint16 is not enough for all the
     image indices.

     See also: im2bw, imcast, im2uint8, im2double, im2int16, im2single.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Convert image to uint16.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
im2uint8


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1060
 -- Function File: im2uint8 (IMG)
 -- Function File: im2uint8 (IMG, "indexed")
     Convert image to uint8.

     The conversion of IMG to an 8-bit unsigned integer, is dependent on
     the type of input image.  The following input classes are supported
     for non-indexed images:

     'int16 or uint16'
          Values are rescaled to the range of the uint8 class [0 255].

     'logical'
          True and false values are assigned a value of 0 and 255
          respectively.

     'double or single'
          Values are truncated to the interval [0 1] and then rescaled
          to the range of values of the int16 class [0 255].

     'uint8'
          Returns the same image.

     If the second argument is the string "indexed", then values are
     cast to uint8, and a -1 offset is applied if input is a floating
     point class.  Input checking is performed and an error will be
     throw is the range of values in uint8 is not enough for all the
     image indices.

     See also: im2bw, imcast, im2double, im2int16, im2single, im2uint16.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Convert image to uint8.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
imabsdiff


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 787
 -- Function File: OUT = imabsdiff (A, B)
 -- Function File: OUT = imabsdiff (A, B, CLASS)
     Return absolute difference of image or constant to an image.

     If A and B are two images of same size and class, returns the
     absolute difference between B and A.

     The class of OUT will be the same as A unless A is logical in which
     case OUT will be double.  Alternatively, the class can be specified
     with CLASS.

     _Note 1_: you can force output class to be logical by specifying
     CLASS.  This is incompatible with MATLAB which will _not_ honour
     request to return a logical matrix.

     _Note 2_: the values are truncated to the mininum value of the
     output class.

     See also: imadd, imcomplement, imdivide, imlincomb, immultiply,
     imsubtract.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Return absolute difference of image or constant to an image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
imadd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 812
 -- Function File: OUT = imadd (A, B)
 -- Function File: OUT = imadd (A, B, CLASS)
     Add image or constant to an image.

     If A and B are two images of same size and class, the images are
     added.  Alternatively, if B is a floating-point scalar, its value
     is added to the image A.

     The class of OUT will be the same as A unless A is logical in which
     case OUT will be double.  Alternatively, it can be specified with
     CLASS.

     _Note 1_: you can force output class to be logical by specifying
     CLASS.  This is incompatible with MATLAB which will _not_ honour
     request to return a logical matrix.

     _Note 2_: the values are truncated to the maximum value of the
     output class.

     See also: imabsdiff, imcomplement, imdivide, imlincomb, immultiply,
     imsubtract.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Add image or constant to an image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
imadjust


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3191
 -- Function File: imadjust (I)
 -- Function File: imadjust (I, [LOW_IN; HIGH_IN])
 -- Function File: imadjust (I, [LOW_IN; HIGH_IN],[LOW_OUT; HIGH_OUT])
 -- Function File: imadjust (..., GAMMA)
 -- Function File: imadjust (CMAP, ...)
 -- Function File: imadjust (RGB, ...)
     Adjust image or colormap intensity (values).

     Returns an image of equal dimensions to I, CMAP, or RGB, with its
     intensity values adjusted, usually for the purpose of increasing
     the image contrast.

     The values are rescaled according to the input and output limits,
     LOW_IN and HIGH_IN, and LOW_OUT and HIGH_OUT respectively.  The
     first pair sets the lower and upper limits on the input image,
     values above and below them being clipped.  The second pair sets
     the lower and upper limits for the output image, the interval to
     which the image will be scaled after clipping the input limits.

     For example:

          imadjust (img, [0.2; 0.9], [0; 1])

     will clip all values in IMG outside the range [0.2 0.9], and then
     rescale them linearly into the range [0 1].

     The input and output limits must be defined as arrays of 2 rows
     with values in the [0 1] range.  Each 2 rows column corresponds to
     a single plane in the input image (or each column of a colormap),
     thus supporting images with any number of dimensions.  If the
     limits have only 2 elements, the same limits are on all planes.
     This format is matched to 'stretchlim' which is designed to create
     the input limits for 'imadjust'.

     By default, the limits are adjusted to maximize the contrast, using
     the whole range of values in the image class; and cause a 2%
     saturation (1% on the lower and upper end of the image).  It is
     equivalent to:

          imadjust (I, stretchlim (I, 0.01), [0; 1])

     A common usage is to maximize the display range without saturation:

          imadjust (img, stretchlim (img, 0)) # adjustment performed per plane
          imadjust (img, stretchlim (img(:), 0)) # equal adjustment to all planes

     For sake of MATAB compatibility, an empty array in any of the
     limits is interpreted as '[0; 1]'.

     If LOW_OUT is higher than HIGH_OUT, the output image will be
     reversed (image negative or complement).

     The GAMMA value shapes the mapping curve between the input and
     output elements.  It defaults to 1, a linear mapping.  Higher
     values of GAMMA will curve the mapping downwards and to the right,
     increasing the contrast in the brighter (higher) values of the
     input image.  Lower values of GAMMA will curve the mapping upwards
     and to the left, increasing the contrast in the darker (lower)
     values of the input image.

     As with the limits, GAMMA can have different values for each plane,
     a 1 row column per plane, thus supporting input images with any
     number of dimensions.  If only a scalar, the same value is used in
     all planes.

     The formula used to perform the mapping (omitting saturation) is:

          low_out + (high_out - low_out) .* ((I - low_in) / (high_in - low_in)) .^ gamma

     See also: brighten, contrast, histeq, stretchlim.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Adjust image or colormap intensity (values).



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
imattributes


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1290
 -- Function File: imattributes ()
 -- Function File: imattributes (HIMAGE)
     Get information about image attributes.

     Return attributes for the image in the current figure or in the
     image handle HIMAGE.  Returns a struct with the fields:

     "Width"
          Number of columns.

     "Height"
          Number of rows.

     "Class"
          Note that some classes are converted to double for display.

     "Image type"
          One of "binary", "truecolor", "intensity", or "indexed".

     "Minimum intensity"
     "Maximum intensity"
          These values are not returned for images of type "truecolor"
          and "binary".

          For indexed images, the returned values are the lowest and
          highest index for the colormap, _not_ the used index for the
          lowest or highest intensity or their values.  This weird
          behaviour is kept for Matlab compatibility.

     This function is meant to be used in an interactive session, and
     not programatically.  The properties of an image should be measured
     from the image variable itself not from the figure object.  In
     addition this function is purposely Matlab incompatible on their
     return value which returns a cell array of strings which is only
     useful for display.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Get information about image attributes.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
imbothat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 602
 -- Function File: imbothat (IMG, SE)
     Perform morphological bottom hat filtering.

     The matrix IMG must be numeric while SE can be a:
        * strel object;
        * array of strel objects as returned by '@strel/getsequence';
        * matrix of 0's and 1's.

     A bottom hat transform corresponds to the difference between the
     closing of IMG and IMG itself, i.e., it is equivalent to:
          imclose (img, se) - img;

     A bottom-hat transform is also known as 'black', or 'closing',
     top-hat transform.

     See also: imerode, imdilate, imopen, imclose, imtophat, mmgradm.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Perform morphological bottom hat filtering.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
imcast


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 905
 -- Function File: imcast (IMG, TYPE)
 -- Function File: imcast (IMG, TYPE, "indexed")
     Convert image to specific data type TYPE.

     Converts a valid image IMG into another class TYPE.  A valid image
     must be of class logical, uint8, uint16, int16, single, or double.
     Conversion of images of class logical is valid, but not the
     inverse, i.e., conversion of images into logical class is not
     supported.  Use of 'im2bw' is recommended for such cases.

     If the image is indexed, the last argument may be the string
     "indexed".  An indexed image may not be of class int16 or single
     (see 'isind' for details).

     Details on how the conversion is performed is class dependent, and
     can be seen on the help text of 'im2double', 'im2single',
     'im2uint8', 'im2uint16', and 'im2int16'.

     See also: im2bw, im2uint8, im2double, im2int16, im2single,
     im2uint16.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Convert image to specific data type TYPE.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
imclearborder


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1040
 -- Function File: imclearborder (IM)
 -- Function File: imclearborder (IM, CONN)
     Clear borders of objects or ligher structures.

     On the simplest case of binary images, this function removes
     objects that touch the image borders.  In the case of grayscale
     images, lighter regions (higher intensity values) that touch the
     image border get removed.

     To be more exact, this is equivalent to use 'imreconstruct' using
     the IM borders as marker, and setting all unchanged elements to a
     background value.

     Element connectivity CONN, to define the size of objects, can be
     specified with a numeric scalar (number of elements in the
     neighborhood):

     '4 or 8'
          for 2 dimensional matrices;
     '6, 18 or 26'
          for 3 dimensional matrices;

     or with a binary matrix representing a connectivity array.
     Defaults to 'conndef (ndims (BW), "maximal")' which is equivalent
     to CONN of 8 and 26 for 2 and 3 dimensional matrices respectively.

     See also: imreconstruct.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Clear borders of objects or ligher structures.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
imclose


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 468
 -- Function File: imclose (IMG, SE)
     Perform morphological closing.

     The matrix IMG must be numeric while SE can be a:
        * strel object;
        * array of strel objects as returned by '@strel/getsequence';
        * matrix of 0's and 1's.

     The closing corresponds to a dilation followed by an erosion of
     IMG, using the same SE, i.e., it is equivalent to:
          imerode (imdilate (img, se), se);

     See also: imdilate, imerode, imopen.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Perform morphological closing.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
imcomplement


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 760
 -- Function File: imcomplement (A)
     Compute image complement or negative.

     Intuitively this corresponds to the intensity of bright and dark
     regions being reversed.  The exact operation performed is dependent
     on the class of the image.

     floating point
          Since floating point images are meant to have values in the
          range [0 1], this is equivalent 'A -1'.  This leads to values
          within the range to be inverted while others to stay equally
          distant from the limits.

     logical
          Equivalent to '! A'

     integer
          Inverts the values within the range of the data type.  This is
          equivalent to 'bitcmp (A)'.

     See also: imadd, imdivide, imlincomb, immultiply, imsubtract.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Compute image complement or negative.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
imcrop


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2163
 -- Function File: imcrop ()
 -- Function File: imcrop (IMG)
 -- Function File: imcrop (IND, CMAP)
 -- Function File: imcrop (H)
 -- Function File: imcrop (..., RECT)
 -- Function File: [CROPPED] = imcrop (...)
 -- Function File: [CROPPED, RECT] = imcrop (...)
 -- Function File: [X, Y, CROPPED, RECT] = imcrop (...)
     Crop image.

     Displays the image IMG in a figure window and waits for the user to
     select two points defining a bounding box.  For an indexed image, a
     corresponding colormap can be specified in CMAP.  For
     multi-dimensional images (each 2D image is concatenated in the 4th
     dimension), only the first image is displayed.

     If no image data is given, uses the current figure or figure from
     graphics handle H.

     Non-interactive usage is supported if the last input argument is 4
     element vector RECT defining the region of interest.  The first two
     elements specify the initial X_INI and Y_INI coordinates, and the
     last two the WIDTH and HEIGHT, i.e., 'RECT = [X_INI Y_INI WIDTH
     HEIGHT]'.  Note how this the opposite of the majority of Octave
     indexing rules where rows come before columns.

     Returns the CROPPED image and a vector RECT with the coordinates
     and size for CROPPED.  If more than 3 output arguments are
     requested, also returns the X and Y data that define the coordinate
     system.

     _Note_: the values in RECT are not necessarily integer values and
     can't always be used directly as index values for other images.  To
     crop the same region from a multiple images of the same size,
     either using a multi-dimensional image:

          nd_img = cat (4, img1, img2, img3, img4);
          cropped = imcrop (nd_img);
          cropped_1 = cropped(:,:,:,1);
          cropped_2 = cropped(:,:,:,2);
          cropped_3 = cropped(:,:,:,3);
          cropped_4 = cropped(:,:,:,4);

     or multiple calls to 'imcrop':

          [cropped_1, rect] = imcrop (img1);
          cropped_2         = imcrop (img2, rect);
          cropped_3         = imcrop (img3, rect);
          cropped_4         = imcrop (img4, rect);

     See also: impixel, imshow.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
Crop image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
imdivide


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 621
 -- Function File: OUT = imdivide (A, B)
 -- Function File: OUT = imdivide (A, B, CLASS)
     Divide image by another image or constant.

     If A and B are two images of same size and class, A is divided by
     B.  Alternatively, if B is a floating-point scalar, A is divided by
     it.

     The class of OUT will be the same as A unless A is logical in which
     case OUT will be double.  Alternatively, it can be specified with
     CLASS.

     _Note_: the values are truncated to the mininum value of the output
     class.

     See also: imabsdiff, imadd, imcomplement, immultiply, imlincomb,
     imsubtract.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 42
Divide image by another image or constant.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
imextendedmax


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1079
 -- Function File:  imextendedmax (IM, H)
 -- Function File:  imextendedmax (IM, H, CONN)
     Caculate the (morphological) extended maxima of an image IM.

     This function returns a binary image that marks the extended maxima
     of the input image IM.  Those extended maxima are definded as the
     regional maxima of the h-maximum transform of the input image
     (which removed all regional maxima of a height less then h
     beforehand).

     The input image IM needs to be a real and nonsparse numeric array
     (of any dimension), and the height parameter H a non-negative
     scalar number.

     The definition of "neighborhood" for this morphological operation
     can be set with the connectivity parameter CONN, which defaults to
     8 for 2D images, to 26 for 3D images and to 'conn(ndims(n),
     "maximal")' in general.  CONN can be given as scalar value or as a
     boolean matrix (see 'conndef' for details).

     The output is a binary image of same shape as the input image IM.

     See also: imextendedmin, imhmax, imregionalmax, imreconstruct.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Caculate the (morphological) extended maxima of an image IM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
imextendedmin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1072
 -- Function File:  imextendedmin (IM, H)
 -- Function File:  imextendedmin (IM, H, CONN)
     Caculate the (morphological) extended minima of an image IM.

     This function returns a binary image that marks the extended minima
     of the input image IM.  Those extended minima are definded as the
     regional minima of the h-minima transform of the input image (which
     removed all regional minima of a depth less then h beforehand).

     The input image IM needs to be a real and nonsparse numeric array
     (of any dimension), and the height parameter H a non-negative
     scalar number.

     The definition of "neighborhood" for this morphological operation
     can be set with the connectivity parameter CONN, which defaults to
     8 for 2D images, to 26 for 3D images and to 'conn(ndims(n),
     "maximal")' in general.  CONN can be given as scalar value or as a
     boolean matrix (see 'conndef' for details).

     The output is a binary image of same shape as the input image IM.

     See also: imextendedmax, imhmin, imregionalmin, imreconstruct.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 60
Caculate the (morphological) extended minima of an image IM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
imfill


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1419
 -- Function File: BW2 = imfill (BW, "holes")
 -- Function File: BW2 = imfill (BW, CONN, "holes")
 -- Function File: BW2 = imfill (BW, LOCATIONS)
 -- Function File: BW2 = imfill (BW, LOCATIONS, CONN)
 -- Function File: I2 = imfill (I)
 -- Function File: I2 = imfill (I, "holes")
 -- Function File: I2 = imfill (I, CONN)
 -- Function File: I2 = imfill (I, CONN, "holes")
     Fill image holes or regions.

     The image to be filled can be binary BW or grayscale I.  Regions
     are a series of connected elements whose values are lower than at
     least one of its neighbor elements.

     The option "holes", default for grayscale images, can be used to
     fill all holes, i.e., regions without border elements.

     Alternatively, the argument LOCATIONS are coordinates for elements
     in the regions to be filled.  It can be a a N-by-1 vector of linear
     indices or a N-by-D matrix of subscript indices where N is the
     number of points and D is the number of dimensions in the image.

     The argument CONN specifies the connectivity used for filling the
     region and defaults to 'conndef (ndims (IMG, "minimal")' which is 4
     for the case of 2 dimensional images.

          im = [0  1  0
                1  0  1
                0  1  0];

          imfill (im, "holes")
          ans =

           0  1  0
           1  1  1
           0  1  0

     See also: bwfill, bwselect, imreconstruct.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Fill image holes or regions.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
imfilter


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1463
 -- Function File: J = imfilter(I, F)
 -- Function File: J = imfilter(I, F, OPTIONS, ...)
     Computes the linear filtering of the image I and the filter F.  The
     computation is performed using double precision floating point
     numbers, but the class of the input image is preserved as the
     following example shows.
          I = 255*ones(100, 100, "uint8");
          f = fspecial("average", 3);
          J = imfilter(I, f);
          class(J)
          => ans = uint8

     The function also accepts a number of optional arguments that
     control the details of the filtering.  The following options is
     currently accepted
     'S'
          If a scalar input argument is given, the image is padded with
          this scalar as part of the filtering.  The default value is 0.
     '"symmetric"'
          The image is padded symmetrically.
     '"replicate"'
          The image is padded using the border of the image.
     '"circular"'
          The image is padded by circular repeating of the image
          elements.
     '"same"'
          The size of the output image is the same as the input image.
          This is the default behaviour.
     '"full"'
          Returns the full filtering result.
     '"corr"'
          The filtering is performed using correlation.  This is the
          default behaviour.
     '"conv"'
          The filtering is performed using convolution.

     See also: conv2, filter2, fspecial, padarray.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Computes the linear filtering of the image I and the filter F.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
imfindcircles


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3551
 -- Function File: CENTERS = imfindcircles (IM, RADIUS)
 -- Function File: CENTERS = imfindcircles (IM, RADIUSRANGE)
 -- Function File: CENTERS = imfindcircles (..., PROPERTY, VALUE)
 -- Function File: [CENTERS, RADII, STRENGTHS] = imfindcircles (...)
     Find circles in image using the circular Hough transform.

     This function finds circles in a given 2d image IM.  The image data
     can be grayscale, rgb color, or binary.  The search is done only
     for circular shapes of approximatly the given RADIUS (single value)
     or RADIUSRANGE (a two element vector [r_min, r_max]).

     The output CENTERS is a two column matrix, where each row contains
     the (fractional) x and y coordinates of the center of one found
     circle.  The output rows are ordered according the STRENGTHS of the
     circles, the strongest circle first.

     The output RADII is a column vector of the (fractional) radii of
     the found circles, in the same order as the circle centers.  If
     RADIUS is specified, instead of RADIUSRANGE, then all values in
     RADII are the same as RADIUS.

     The output STRENGTHS is a measure of how "strong" the corresponding
     circle is.  (A sharp, smooth and full circle gives roughly a value
     of one.  The minimum value is zero.)

     Additionally the following optional property-value-pairs can be
     used:
     OBJECTPOLARITY
          Either "bright" circles on darker background can be searched
          (default), or "dark" circles on brighter background.

     METHOD
          The default method "PhaseCode" is faster as the (currently
          unimplemented) method "TwoStage".  For literature and details
          on the algorithm, see comments in the code.

     SENSITIVITY
          A value between 0 and 1 to say how strong a circle must be in
          order to be found.  With a value of 1 no circles are
          discarded, default value is 0.85.  (Use bigger values of
          Sensitivity if your circles are not properly found, until
          unwanted "ghost" circles start to appear.)

     EDGETHRESHOLD
          A value between 0 and 1 to say how strong an edge point of the
          image must be, to be considered as a possible point on a
          circle circumference.  With a value of 0 all possible edge
          points are considered, with a value of 1 only the edge point
          with the stronges gradient will be considered.  As default
          value the output of 'graythresh' (Otsu's threshold) of the
          gradient image is taken.

     Notes:
        * Only center points inside the image region can be found.
        * For concentric cirles the output is unpredictable.
        * For optimal speed, keep the radius range and the image size as
          small as possible.
        * For radius values above 100 pixels the sensitivity and
          accuracy of this algorithm starts to decrease.
        * For big radius ranges the sensitivity decreases.  Try to keep
          r_max < 3 * r_min .
        * RGB color images will automatically be converted to grayscale
          using the 'rgb2gray' function.
        * Binary images will automatically be converted to grayscale and
          be slightly smoothed before processing.

     Compatibility note: The CENTERS and RADII outputs have good
     compatibility to the Matlab outputs.  The STRENGTHS outputs differ
     a bit, but have mostly the same ordering.  Currently only the
     (default) Matlab algorithm "PhaseCode" is implemented in Octave.

     See also: hough, hough_circle.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Find circles in image using the circular Hough transform.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
imgetfile


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1885
 -- Function File: [PATH, FLAG] = imgetfile ()
 -- Function File: [...] = imgetfile (OPTIONS, ...)
     Open GUI dialogue to select image files.

     The GUI dialogue opened is exactly the same as 'uigetfile' but uses
     recognized image file formats as file filter.  All other options
     from 'uigetfile' are accepted.

     The return value PATH is a string with the full filepath of the
     selected file.  If the "MultiSelect" option is selected, then a
     cell array of strings is returned.

     FLAG is a logical value, true if there was any issue with file
     selection such as the user closing or cancelling the dialogue with
     selecting a file.  It has a value of false otherwise.

          [filepath, flag] = imgetfile ();
          if (flag)
            error ("A file must be selected");
          endif

     There is no guarantee that 'imread' will be capable to read all
     files selected via this dialogue.  Possible reasons for this are:

        * the filter uses all the extensions as obtained from
          'imformats'.  This only means that a format with such
          extensions is registered, not necessarily that read or write
          support has been implemented;

        * the dialogue also has a "All files (*)" filter, so a user is
          actually able to select any file;

        * the file may be corrupt;

        * it is the file content, and not the file extension, that
          defines the file format.  A file may have a file extension
          that is equal to an image file format and not actually be an
          image file.

     The opposite is also true.  'imread' is able to guess the file
     format even when the file extension is incorrect (or even in the
     absence of a file extension).  A file that is filtered out may
     still be readable by 'imread' or 'imfinfo'.

     See also: imformats, uigetfile.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Open GUI dialogue to select image files.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
imgradient


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 895
 -- Function File: [GRADMAG, GRADDIR] = imgradient (IMG)
 -- Function File: [GRADMAG, GRADDIR] = imgradient (IMG, METHOD)
 -- Function File: [GRADMAG, GRADDIR] = imgradient (GX, GY)
     Compute the gradient magnitude and direction in degrees for an
     image.

     These are computed from the GX and XY gradients using
     'imgradientxy'.  The first input IMG is a gray scale image to
     compute the edges on.  The second input METHOD controls the method
     used to calculate the gradients.  Alternatively the first input GX
     can be the x gradient and the second input GY can be the y
     gradient.

     The first output GRADMAG returns the magnitude of the gradient.
     The second output GRADDIR returns the direction in degrees.

     The METHOD input argument must be a string specifying one of the
     methods supported by 'imgradientxy'.

     See also: edge, imgradientxy.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Compute the gradient magnitude and direction in degrees for an image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 12
imgradientxy


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1247
 -- Function File: [GRADX, GRADY] = imgradientxy (IMG)
 -- Function File: [GRADX, GRADY] = imgradientxy (IMG, METHOD)
     Compute the x and y gradients of an image using various methods.

     The first input IMG is the gray scale image to compute the edges
     on.  The second input METHOD controls the method used to calculate
     the gradients.

     The first output GRADX returns the gradient in the x direction.
     The second output GRADY returns the gradient in the y direction.

     The METHOD input argument can be any of the following strings:

     "sobel" (default)
          Calculates the gradient using the Sobel approximation to the
          derivatives.

     "prewitt"
          Calculates the gradient using the Prewitt approximation to the
          derivatives.  This method works just like Sobel except a
          different approximation of the gradient is used.

     "central difference"
          Calculates the gradient using the central difference
          approximation to the derivatives: '(x(i-1) - x(i+1))/2'.

     "intermediate difference"
          Calculates the gradient in using the intermediate difference
          approximation to the derivatives: 'x(i) - x(i+1)'.

     See also: edge, imgradient.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 64
Compute the x and y gradients of an image using various methods.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
imhist


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 824
 -- Function File: imhist (I)
 -- Function File: imhist (I, N)
 -- Function File: imhist (X, CMAP)
 -- Function File: [COUNTS, X] = imhist (...)
     Produce histogram counts of image I.

     The second argument can either be N, a scalar that specifies the
     number of bins; or CMAP, a colormap in which case X is expected to
     be an indexed image.  If not specified, N defaults to 2 for binary
     images, and 256 for grayscale images.

     If output is requested, COUNTS is the number of counts for each bin
     and X is a range for the bins so that 'stem (X, COUNTS)' will show
     the histogram.

     _Note:_ specially high peaks that may prevent an overview of the
     histogram may not be displayed.  To avoid this, use 'axis "auto y"'
     after the call to 'imhist'.

     See also: hist, histc, histeq.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Produce histogram counts of image I.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
imhmax


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1365
 -- Function File:  imhmax (IM, H)
 -- Function File:  imhmax (IM, H, CONN)
     Caculate the morphological h-maximum transform of an image IM.

     This function removes all regional maxima in the grayscale image IM
     whose height is lower or equal to the given threshold level H, and
     it decreases the height of the remaining regional maxima by the
     value of H.  (A "regional maximum" is defined as a connected
     component of pixels with an equal pixel value that is higher than
     the value of all its neighboring pixels.  And the "height" of a
     regional maximum can be thought of as minimum pixel value
     difference between the regional maximum and its neighboring
     minima.)

     The input image IM needs to be a real and nonsparse numeric array
     (of any dimension), and the height parameter H a non-negative
     scalar number.

     The definition of "neighborhood" for this morphological operation
     can be set with the connectivity parameter CONN, which defaults to
     8 for 2D images, to 26 for 3D images and to 'conn(ndims(n),
     "maximal")' in general.  CONN can be given as scalar value or as a
     boolean matrix (see 'conndef' for details).

     The output is a transformed grayscale image of same type and shape
     as the input image IM.

     See also: imhmin, imregionalmax, imextendedmax, imreconstruct.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Caculate the morphological h-maximum transform of an image IM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
imhmin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1354
 -- Function File:  imhmin (IM, H)
 -- Function File:  imhmin (IM, H, CONN)
     Caculate the morphological h-minimum transform of an image IM.

     This function removes all regional minima in the grayscale image IM
     whose depth is less or equal to the given threshold level H, and it
     increases the depth of the remaining regional minima by the value
     of H.  (A "regional minimum" is defined as a connected component of
     pixels with an equal pixel value that is less than the value of all
     its neighboring pixels.  And the "depth" of a regional minimum can
     be thought of as minimum pixel value difference between the
     regional minimum and its neighboring maxima.)

     The input image IM needs to be a real and nonsparse numeric array
     (of any dimension), and the height parameter H a non-negative
     scalar number.

     The definition of "neighborhood" for this morphological operation
     can be set with the connectivity parameter CONN, which defaults to
     8 for 2D images, to 26 for 3D images and to 'conn(ndims(n),
     "maximal")' in general.  CONN can be given as scalar value or as a
     boolean matrix (see 'conndef' for details).

     The output is a transformed grayscale image of same type and shape
     as the input image IM.

     See also: imhmax, imregionalmin, imextendedmin, imreconstruct.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 62
Caculate the morphological h-minimum transform of an image IM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
imimposemin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1035
 -- Function File:  imimposemin (IM, BW)
 -- Function File:  imimposemin (IM, BW, CONN)
     Modify the input impage IM to only have regional minima at the
     marker positions given by the nonzero pixels of BW.

     This function returns a grayscale image that is similar to IM but
     only has regional minima at pixel positions where the marker image
     BW is nonzero.

     The input image IM needs to be a real and nonsparse numeric array
     (of any dimension).  And the marker image BW needs to be a real or
     logical nonsparse array of identical size.  (The values in BW will
     first be converted to logical values.)

     The definition of "neighborhood" for this morphological operation
     can be set with the connectivity parameter CONN, which defaults to
     8 for 2D images, to 26 for 3D images and to 'conn(ndims(n),
     "maximal")' in general.  CONN can be given as scalar value or as a
     boolean matrix (see 'conndef' for details).

     See also: imextendedmin, imhmin, imregionalmin, imreconstruct.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Modify the input impage IM to only have regional minima at the marker
positions 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
imlincomb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1090
 -- Function File: OUT = imlincomb (FAC, IMG)
 -- Function File: OUT = imlincomb (FAC1, IMG1, FAC2, IMG2, ...)
 -- Function File: OUT = imlincomb (FAC1, IMG1, FAC2, IMG2, ..., K)
 -- Function File: OUT = imlincomb (..., CLASS)
     Combine images linearly.

     Returns the computed image as per:

     OUT = FAC1*IMG1 + FAC2*IMG2 + ... + FACn*IMGn

     or

     OUT = FAC1*IMG1 + FAC2*IMG2 + ... + FACn*IMGn + K

     The images IMG1..n must all be of same size and class.  The factors
     FAC1..n must all be floating-point scalars, and K (if given) is a
     real constant.

     The class of OUT will be the same as IMGs unless IMGs are logical
     in which case OUT will be double.  Alternatively, it can be
     specified with CLASS.

     If applying several arithmetic operations on images, 'imlincomb' is
     more precise since calculations are performed at double precision.

     _Note 1_: you can force output class to be logical by specifying
     CLASS though it possibly doesn't make a lot of sense.

     See also: imadd, imcomplement, imdivide, immultiply, imsubtract.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Combine images linearly.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
immaximas


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1213
 -- Function File: [R, C] = immaximas (IM, RADIUS)
 -- Function File: [R, C] = immaximas (IM, RADIUS, THRESH)
 -- Function File: [R, C, ...] = immaximas (...)
 -- Function File: [..., VAL] = immaximas (...)
     Find local spatial maximas.

     Local spatial maximas should not be mistaken with regional maxima.
     See 'imregionalmax' for the later.

     A local spatial maxima is defined as an image point with a value
     that is larger than all neighbouring values in a square region of
     width 2*RADIUS+1.  By default RADIUS is 1, such that a 3 by 3
     neighbourhood is searched.  If the THRESH input argument is
     supplied, only local maximas with a value greater than THRESH are
     retained.

     The output vectors R and C contain the row-column coordinates of
     the local maximas.  The actual values are computed to sub-pixel
     precision by fitting a parabola to the data around the pixel.  If
     IM is N-dimensional, then N vectors will be returned.

     If IM is N-dimensional, and N+1 outputs are requested, then the
     last output will contain the image values at the maximas.
     Currently this value is not interpolated.

     See also: imregionalmax, ordfilt2, ordfiltn.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Find local spatial maximas.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
immse


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 340
 -- Function File: immse (X, Y)
     Compute mean squared error.

     Calculates the mean squared error (MSE), between the arrays X and
     Y.  X and Y must be of same size and class.

     The returned value will be a scalar double, unless X and Y are of
     class single in which case, it returns a scalar single.

     See also: psnr.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Compute mean squared error.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
immultiply


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 636
 -- Function File: OUT = immultiply (A, B)
 -- Function File: OUT = immultiply (A, B, CLASS)
     Multiply image by another image or constant.

     If A and B are two images of same size and class, the images are
     multiplied.  Alternatively, if B is a floating-point scalar, A is
     multiplied by it.

     The class of OUT will be the same as A unless A is logical in which
     case OUT will be double.  Alternatively, it can be specified with
     CLASS.

     _Note_: the values are truncated to the mininum value of the output
     class.

     See also: imabsdiff, imadd, imcomplement, imdivide, imlincomb,
     imsubtract.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 44
Multiply image by another image or constant.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
imnoise


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 751
 -- Function File: imnoise (A, TYPE)
 -- Function File: imnoise (..., OPTIONS)
     Add noise to image.

 -- Function File: imnoise (A, "gaussian", MEAN, VARIANCE)
     Additive gaussian noise with MEAN and VARIANCE defaulting to 0 and
     0.01.

 -- Function File: imnoise (A, "poisson")
     Creates poisson noise in the image using the intensity value of
     each pixel as mean.

 -- Function File: imnoise (A, "salt & pepper", DENSITY)
     Create "salt and pepper"/"lost pixels" in DENSITY*100 percent of
     the image.  DENSITY defaults to 0.05.

 -- Function File: imnoise (A, "speckle", VARIANCE)
     Multiplicative gaussian noise with B = A + A * noise with mean 0
     and VARIANCE defaulting to 0.04.

     See also: rand, randn, randp.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 19
Add noise to image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
imopen


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 468
 -- Function File: imopen (IMG, SE)
     Perform morphological opening.

     The matrix IMG must be numeric while SE can be a:
        * strel object;
        * array of strel objects as returned by '@strel/getsequence';
        * matrix of 0's and 1's.

     The opening corresponds to an erosion followed by a dilation of
     IMG, using the same SE, i.e., it is equivalent to:
          imdilate (imerode (img, se), se);

     See also: imdilate, imerode, imclose.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Perform morphological opening.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
imperspectivewarp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1625
 -- Function File: WARPED = imperspectivewarp(IM, P, INTERP, BBOX,
          EXTRAPVAL)
 -- Function File: [WARPED, VALID] = imperspectivewarp(...)
     Applies the spatial perspective homogeneous transformation P to the
     image IM.  The transformation matrix P must be a 3x3 homogeneous
     matrix, or 2x2 or 2x3 affine transformation matrix.

     The optional argument METHOD defines the interpolation method to be
     used.  All methods supported by 'interp2' can be used.  By default,
     the 'linear' method is used.

     For MATLAB compatibility, the methods 'bicubic' (same as 'cubic'),
     'bilinear' and 'triangle' (both the same as 'linear') are also
     supported.

     By default the resulting image contains the entire warped image.
     In some situation you only parts of the warped image.  The argument
     BBOX controls this, and can be one of the following strings
     '"loose"'
          The entire warped result is returned.  This is the default
          behavior.
     '"crop"'
          The central part of the image of the same size as the input
          image is returned.
     '"same"'
          The size and coordinate system, of the input image, are kept.

     All values of the result that fall outside the original image will
     be set to EXTRAPVAL.  The default value of EXTRAPVAL is 0.

     The optional output VALID is a matrix of the same size as WARPED
     that contains the value 1 in pixels where WARPED contains an
     interpolated value, and 0 in pixels where WARPED contains an
     extrapolated value.

     See also: imremap, imrotate, imresize, imshear, interp2.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 77
Applies the spatial perspective homogeneous transformation P to the
image IM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
impixel


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1005
 -- Function File: impixel ()
 -- Function File: impixel (IMG, X, Y)
 -- Function File: impixel (IND, MAP, X, Y)
 -- Function File: impixel (XDATA, YDATA, IMG, X, Y)
 -- Function File: impixel (XDATA, YDATA, IND, MAP, X, Y)
 -- Function File: [X, Y, P] = impixel (...)
     Get pixel values.

     For any image IMG, or indexed image IND with colormap MAP, returns
     the pixel values at the image coordinates X and Y.

     The 2 element vectors XDATA and YDATA can be used to set an
     alternative coordinate system.

     If more than one output argument is requested, also returns the X
     and Y coordinates for the image.

        * The pixel values are always returned in RGB style triples,
          even when IMG is a grayscale image.

        * The value for pixel coordinates outside the image limits is
          NaN.

        * Because a floating-point is required to represent a NaN, the
          pixel values will be of class double if input is double, and
          single otherwise.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 17
Get pixel values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
impyramid


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1525
 -- Function File: impyramid (IM, DIRECTION)
     Compute gaussian pyramid expansion or reduction.

     Create image which is one level up or down in the Gaussian pyramid.
     DIRECTION must be "reduce" or "expand".  These operations are only
     done in the first two dimensions, so that even if IM is a N
     dimensional array, only the number of rows and columns will change.

     The "reduce" stage is done by low-pass filtering and subsampling of
     1:2 in each axis.  If the size of the original image is [M N], the
     size of the reduced image is [ceil((M+1)/2) ceil((N+1)/2)].

     The "expand" stage is done by upsampling the image (2:1 in each
     axis), and then low-pass filtering.  If the size of the original
     image is [M N], the size of the expanded image is '[2M-1 2N-1]'.

     Note that image processing pyramids are upside down, so "reduce" is
     going one level _down_ in the pyramid, while "expand" is going one
     level _up_ in the pyramid.

          impyramid (im, "reduce");   # return reduced image (one level down)
          impyramid (im, "expand");   # return expanded image (one level up)

     The low-pass filter is defined according to Burt & Adelson [1]
     'W(i,j) = w(i)w(j)' where 'w = [0.25-alpha/2 0.25 alpha 0.25
     0.25-alpha/2]' with 'alpha = 0.375'

     [1] Peter J. Burt and Edward H. Adelson (1983).  The Laplacian
     Pyramid as a Compact Image Code.  IEEE Transactions on
     Communications, vol.  COM-31(4), 532-540.

     See also: imresize, imfilter.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 48
Compute gaussian pyramid expansion or reduction.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
imquantize


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1611
 -- Function File: [QUANT, IDX] = imquantize (IMG, LEVELS)
 -- Function File: [...] = imquantize (IMG, LEVELS, VALUES)
     Quantize image with multiple threshold levels and values.

     This function reduces the number of unique values in IMG by
     performing multiple thresholds, one for each element in LEVELS, and
     assigning it values from VALUES.

     The output QUANT is the quantized image, of same size as IMG and
     same class as VALUES.  IDX are the indices into VALUES such that
     'QUANT == VALUES(IDX)'.

     For the simpler case where VALUES is not defined, it defaults to
     '1:N+1' and this function becomes equivalent to:

          out = ones (size (IMG));
          for i = 1:numel(LEVELS)
            out(IMG > LEVELS(i)) += 1;
          endfor

     So that for example:

          >> img = [1 2 3; 4 5 6; 7 8 9];
          >> imquantize (img, [3 6])
             => ans =

                   1   1   1
                   2   2   2
                   3   3   3

     For the more general case, when VALUES is defined, this function is
     equivalent to:

          LEVELS = [-Inf LEVELS Inf];
          out = zeros (size (IMG), class (VALUES));
          for i = 1:numel(VALUES)
            out(IMG > LEVELS(i) & IMG <= LEVELS(i+1)) = VALUES(i);
          endfor

     So that for example:

          >> img = [1 2 3; 4 5 6; 7 8 9];
          >> imquantize (img, [3 6], [0 5 8])
             => ans =

                   0   0   0
                   5   5   5
                   8   8   8

     See also: gray2ind, ind2gray, ind2rgb, intlut, label2rgb, lookup,
     rgb2ind.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Quantize image with multiple threshold levels and values.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
imregionalmax


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 894
 -- Function File: imregionalmax (IMG)
 -- Function File: imregionalmax (IMG, CONN)
     Compute regional maxima.

     Returns a logical matrix, same size as the input IMG, with the
     regional maxima.

     The optional argument CONN, defines the connectivity.  It can be a
     scalar value or a boolean matrix (see 'conndef' for details).
     Defaults to 'conndef (ndims (IMG), "maximal")'

     Regional maxima should not be mistaken with local maxima.  Local
     maxima are pixels whose value is greater or equal to all of its
     neighbors.  A regional maxima is the connected component of pixels
     whose values are all higher than the neighborhood of the maxima
     (the connected component, not its individual pixels).  All pixels
     belonging to a regional maximum are local maxima, but the inverse
     is not true.

     See also: immaximas, imreconstruct, imregionalmin.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Compute regional maxima.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
imregionalmin


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 877
 -- Function File: imregionalmin (IMG)
 -- Function File: imregionalmin (IMG, CONN)
     Compute regional minima.

     Returns a logical matrix, same size as the input IMG, with the
     regional minima.

     The optional argument CONN, defines the connectivity.  It can be a
     scalar value or a boolean matrix (see 'conndef' for details).
     Defaults to 'conndef (ndims (IMG), "maximal")'

     Regional minima should not be mistaken with local minima.  Local
     minima are pixels whose value is less or equal to all of its
     neighbors.  A regional minima is the connected component of pixels
     whose values are all less than the neighborhood of the minima (the
     connected component, not its individual pixels).  All pixels
     belonging to a regional minima are local minima, but the inverse is
     not true.

     See also: imreconstruct, imregionalmax.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 24
Compute regional minima.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
imremap


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1329
 -- Function File: WARPED = imremap(IM, XI, YI)
 -- Function File: WARPED = imremap(IM, XI, YI, INTERP, EXTRAPVAL)
 -- Function File: [WARPED, VALID ] = imremap(...)
     Applies any geometric transformation to the image IM.

     The arguments XI and YI are lookup tables that define the resulting
     image
          WARPED(y,x) = IM(YI(y,x), XI(y,x))
     where IM is assumed to be a continuous function, which is achieved
     by interpolation.  Note that the image IM is expressed in a (X,
     Y)-coordinate system and not a (row, column) system.

     The optional argument METHOD defines the interpolation method to be
     used.  All methods supported by 'interp2' can be used.  By default,
     the 'linear' method is used.

     For MATLAB compatibility, the methods 'bicubic' (same as 'cubic'),
     'bilinear' and 'triangle' (both the same as 'linear') are also
     supported.

     All values of the result that fall outside the original image will
     be set to EXTRAPVAL.  The default value of EXTRAPVAL is 0.

     The optional output VALID is a matrix of the same size as WARPED
     that contains the value 1 in pixels where WARPED contains an
     interpolated value, and 0 in pixels where WARPED contains an
     extrapolated value.

     See also: imperspectivewarp, imrotate, imresize, imshear, interp2.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 53
Applies any geometric transformation to the image IM.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
imresize


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1203
 -- Function File: imresize (IM, SCALE)
 -- Function File: imresize (IM, [M N])
 -- Function File: imresize (..., METHOD)
     Resize image with interpolation

     Scales the image IM by a factor SCALE or into the size M rows by N
     columns.  For example:

          imresize (im, 1);    # return the same image as input
          imresize (im, 1.5);  # return image 1.5 times larger
          imresize (im, 0.5);  # return image with half the size
          imresize (im, 2);    # return image with the double size
          imresize (im, [512 610]); # return image of size 512x610

     If M or N is 'NaN', it will be determined automatically so as to
     preserve aspect ratio.

     The optional argument METHOD defines the interpolation method to be
     used.  All methods supported by 'interp2' can be used.  By default,
     the 'cubic' method is used.

     For MATLAB compatibility, the methods 'bicubic' (same as 'cubic'),
     'bilinear' and 'triangle' (both the same as 'linear') are also
     supported.

     bicubic (default)
          Same as 'cubic'.

     bilinear
          Same as 'linear'.

     triangle
          Same as 'linear'.

     See also: imremap, imrotate, interp2.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Resize image with interpolation



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
imrotate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1552
 -- Function File: imrotate (IMGPRE, THETA, METHOD, BBOX, EXTRAPVAL)
     Rotate image about its center.

     Input parameters:

     IMGPRE a gray-level image matrix

     THETA the rotation angle in degrees counterclockwise

     The optional argument METHOD defines the interpolation method to be
     used.  All methods supported by 'interp2' can be used although as
     of Octave 4.2 the "spline" still does not work.  In addition,
     Fourier interpolation by decomposing the rotation matrix into 3
     shears can be used with the 'fourier' method.  By default, the
     'nearest' method is used.

     For MATLAB compatibility, the methods 'bicubic' (same as 'cubic'),
     'bilinear' and 'triangle' (both the same as 'linear') are also
     supported.

     BBOX
          "loose" grows the image to accommodate the rotated image
          (default).
          "crop" rotates the image about its center, clipping any part
          of the image that is moved outside its boundaries.

     EXTRAPVAL sets the value used for extrapolation.  The default value
     is 0.  This argument is ignored of Fourier interpolation is used.

     Output parameters:

     IMGPOST the rotated image matrix

     H the homography mapping original to rotated pixel coordinates.  To
     map a coordinate vector c = [x;y] to its rotated location, compute
     round((H * [c; 1])(1:2)).

     VALID a binary matrix describing which pixels are valid, and which
     pixels are extrapolated.  This output is not available if Fourier
     interpolation is used.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 30
Rotate image about its center.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
imsharpen


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1424
 -- Function File: imsharpen (IM)
 -- Function File: imsharpen (IM, OPTION, VALUE, ...)
     Sharpen image using unsharp masking.

     IM must be a grayscale or RGB image.  The unsharp masking can be
     controlled with OPTION-VALUE pairs.

     The unsharp masking technique is equivalent to:

          IM + K * (IM - smooth (IM))

     where IM is a grayscale image and 'smooth' performs gaussian
     smoothing.  RGB images are transformed to Lab colorspace, the L
     channel is sharpen to L', and L'ab is transformed back to RGB. See
     "Unsharp masking" in Wikipedia
     (https://en.wikipedia.org/wiki/Unsharp_masking)

     The following options control the unsharp masking:

     "Radius"
          Sigma of Gaussian Filter for the smoothing stage.  Must be a
          positive number.  Defaults to 1.

     "Amount"
          Magnitude of the overshoot K.  Must be a non-negative number.
          Defaults to 0.8.

     "Threshold"
          Minimum brightness change that will be sharpened.  Must be in
          the range [0 1].  Defaults to 0.

     Examples:

          out = imsharpen (im);              # Using imsharpen with default values
          out = imsharpen (im, "Radius", 1.5);
          out = imsharpen (im, "Amount", 1.2);
          out = imsharpen (im, "Threshold", 0.5);
          out = imsharpen (im, "Radius", 1.5, "Amount", 1.2, "Threshold", 0.5);

     See also: imfilter, fspecial.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Sharpen image using unsharp masking.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
imshear


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1177
 -- Function File: imshear (M, AXIS, ALPHA, BBOX)
     Applies a shear to the image M.

     The argument M is either a matrix or an RGB image.

     AXIS is the axis along which the shear is to be applied, and can be
     either 'x' or 'y'.  For example, to shear sideways is to shear
     along the 'x' axis.  Choosing 'y' causes an up/down shearing.

     ALPHA is the slope of the shear.  For an 'x' shear, it is the
     horizontal shift (in pixels) applied to the pixel above the center.
     For a 'y' shear, it is the vertical shift (in pixels) applied to
     the pixel just to the right of the center pixel.

     NOTE: ALPHA does NOT need to be an integer.

     BBOX can be one of 'loose', 'crop' or 'wrap'.  'loose' allows the
     image to grow to accommodate the new transformed image.  'crop'
     keeps the same size as the original, clipping any part of the image
     that is moved outside the bounding box.  'wrap' keeps the same size
     as the original, but does not clip the part of the image that is
     outside the bounding box.  Instead, it wraps it back into the
     image.

     If called with only 3 arguments, BBOX is set to 'loose' by default.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Applies a shear to the image M.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
imsmooth


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7381
 -- Function File: J = imsmooth(I, NAME, OPTIONS)
     Smooth the given image using several different algorithms.

     The first input argument I is the image to be smoothed.  If it is
     an RGB image, each color plane is treated separately.  The variable
     NAME must be a string that determines which algorithm will be used
     in the smoothing.  It can be any of the following strings

     "Gaussian"
          Isotropic Gaussian smoothing.  This is the default.
     "Average"
          Smoothing using a rectangular averaging linear filter.
     "Disk"
          Smoothing using a circular averaging linear filter.
     "Median"
          Median filtering.
     "Bilateral"
          Gaussian bilateral filtering.
     "Perona & Malik"
     "Perona and Malik"
     "P&M"
          Smoothing using nonlinear isotropic diffusion as described by
          Perona and Malik.
     "Custom Gaussian"
          Gaussian smoothing with a spatially varying covariance matrix.

     In all algorithms the computation is done in double precision
     floating point numbers, but the result has the same type as the
     input.  Also, the size of the smoothed image is the same as the
     input image.

     *Isotropic Gaussian smoothing*

     The image is convolved with a Gaussian filter with spread SIGMA.
     By default SIGMA is 0.5, but this can be changed.  If the third
     input argument is a scalar it is used as the filter spread.

     The image is extrapolated symmetrically before the convolution
     operation.

     *Rectangular averaging linear filter*

     The image is convolved with N by M rectangular averaging filter.
     By default a 3 by 3 filter is used, but this can e changed.  If the
     third input argument is a scalar N a N by N filter is used.  If the
     third input argument is a two-vector '[N, M]' a N by M filter is
     used.

     The image is extrapolated symmetrically before the convolution
     operation.

     *Circular averaging linear filter*

     The image is convolved with circular averaging filter.  By default
     the filter has a radius of 5, but this can e changed.  If the third
     input argument is a scalar R the radius will be R.

     The image is extrapolated symmetrically before the convolution
     operation.

     *Median filtering*

     Each pixel is replaced with the median of the pixels in the local
     area.  By default, this area is 3 by 3, but this can be changed.
     If the third input argument is a scalar N the area will be N by N,
     and if it's a two-vector [N, M] the area will be N by M.

     The image is extrapolated symmetrically before the filtering is
     performed.

     *Gaussian bilateral filtering*

     The image is smoothed using Gaussian bilateral filtering as
     described by Tomasi and Manduchi [2].  The filtering result is
     computed as
          J(x0, y0) = k * SUM SUM I(x,y) * w(x, y, x0, y0, I(x0,y0), I(x,y))
                           x   y
     where 'k' a normalisation variable, and
          w(x, y, x0, y0, I(x0,y0), I(x,y))
            = exp(-0.5*d([x0,y0],[x,y])^2/SIGMA_D^2)
              * exp(-0.5*d(I(x0,y0),I(x,y))^2/SIGMA_R^2),
     with 'd' being the Euclidian distance function.  The two parameters
     SIGMA_D and SIGMA_R control the amount of smoothing.  SIGMA_D is
     the size of the spatial smoothing filter, while SIGMA_R is the size
     of the range filter.  When SIGMA_R is large the filter behaves
     almost like the isotropic Gaussian filter with spread SIGMA_D, and
     when it is small edges are preserved better.  By default SIGMA_D is
     2, and SIGMA_R is 10/255 for floating points images (with integer
     images this is multiplied with the maximal possible value
     representable by the integer class).

     The image is extrapolated symmetrically before the filtering is
     performed.

     *Perona and Malik*

     The image is smoothed using nonlinear isotropic diffusion as
     described by Perona and Malik [1].  The algorithm iteratively
     updates the image using

          I += lambda * (g(dN).*dN + g(dS).*dS + g(dE).*dE + g(dW).*dW)

     where 'dN' is the spatial derivative of the image in the North
     direction, and so forth.  The function G determines the behaviour
     of the diffusion.  If g(x) = 1 this is standard isotropic
     diffusion.

     The above update equation is repeated ITER times, which by default
     is 10 times.  If the third input argument is a positive scalar,
     that number of updates will be performed.

     The update parameter LAMBDA affects how much smoothing happens in
     each iteration.  The algorithm can only be proved stable is LAMBDA
     is between 0 and 0.25, and by default it is 0.25.  If the fourth
     input argument is given this parameter can be changed.

     The function G in the update equation determines the type of the
     result.  By default 'G(D) = exp(-(D./K).^2)' where K = 25.  This
     choice gives privileges to high-contrast edges over low-contrast
     ones.  An alternative is to set 'G(D) = 1./(1 + (D./K).^2)', which
     gives privileges to wide regions over smaller ones.  The choice of
     G can be controlled through the fifth input argument.  If it is the
     string '"method1"', the first mentioned function is used, and if it
     is "METHOD2" the second one is used.  The argument can also be a
     function handle, in which case the given function is used.  It
     should be noted that for stability reasons, G should return values
     between 0 and 1.

     The following example shows how to set 'G(D) = exp(-(D./K).^2)'
     where K = 50.  The update will be repeated 25 times, with LAMBDA =
     0.25.

          G = @(D) exp(-(D./50).^2);
          J = imsmooth(I, "p&m", 25, 0.25, G);

     *Custom Gaussian Smoothing*

     The image is smoothed using a Gaussian filter with a spatially
     varying covariance matrix.  The third and fourth input arguments
     contain the Eigenvalues of the covariance matrix, while the fifth
     contains the rotation of the Gaussian.  These arguments can be
     matrices of the same size as the input image, or scalars.  In the
     last case the scalar is used in all pixels.  If the rotation is not
     given it defaults to zero.

     The following example shows how to increase the size of an Gaussian
     filter, such that it is small near the upper right corner of the
     image, and large near the lower left corner.

          [LAMBDA1, LAMBDA2] = meshgrid (linspace (0, 25, columns (I)), linspace (0, 25, rows (I)));
          J = imsmooth (I, "Custom Gaussian", LAMBDA1, LAMBDA2);

     The implementation uses an elliptic filter, where only neighbouring
     pixels with a Mahalanobis' distance to the current pixel that is
     less than 3 are used to compute the response.  The response is
     computed using double precision floating points, but the result is
     of the same class as the input image.

     *References*

     [1] P. Perona and J. Malik, "Scale-space and edge detection using
     anisotropic diffusion", IEEE Transactions on Pattern Analysis and
     Machine Intelligence, 12(7):629-639, 1990.

     [2] C. Tomasi and R. Manduchi, "Bilateral Filtering for Gray and
     Color Images", Proceedings of the 1998 IEEE International
     Conference on Computer Vision, Bombay, India.

     See also: imfilter, fspecial.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Smooth the given image using several different algorithms.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
imsubtract


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1216
 -- Function File: OUT = imsubtract (A, B)
 -- Function File: OUT = imsubtract (A, B, CLASS)
     Subtract image or constant to an image.

     If A and B are two images of same size and class, B is subtracted
     to A.  Alternatively, if B is a floating-point scalar, its value is
     subtracted to the image A.

     The class of OUT will be the same as A unless A is logical in which
     case OUT will be double.  Alternatively, it can be specified with
     CLASS.

     _Note 1_: you can force output class to be logical by specifying
     CLASS.  This is incompatible with MATLAB which will _not_ honour
     request to return a logical matrix.

     _Note 2_: the values are truncated to the mininum value of the
     output class.

     _Note 3_: values are truncated before the operation so if input
     images are unsigned integers and the request output class is a
     signed integer, it may lead to unexpected results:

          imsubtract (uint8 ([23 190]), uint8 ([24 200]), "int8")
               => -1  0

     Because both 190 and 200 were truncated to 127 before subtraction,
     their difference is zero.

     See also: imabsdiff, imadd, imcomplement, imdivide, imlincomb,
     immultiply.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Subtract image or constant to an image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
imtophat


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 619
 -- Function File: imtophat (IMG, SE)
     Perform morphological top hat filtering.

     The matrix IMG must be numeric while SE can be a:
        * strel object;
        * array of strel objects as returned by '@strel/getsequence';
        * matrix of 0's and 1's.

     A top hat transform corresponds to the difference between IMG, and
     the opening of IMG, i.e., it is equivalent to:
          img - imopen (img, se);

     Use 'imbothat' to perform a 'black' or 'closing', top-hat transform
     (is is also known as bottom-hat transform).

     See also: imerode, imdilate, imopen, imclose, imbothat, mmgradm.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Perform morphological top hat filtering.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
imtransform


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2539
 -- Function File: IM_OUT = imtransform (IM_IN, T)
 -- Function File: IM_OUT = imtransform (IM_IN, T, INTERP)
 -- Function File: IM_OUT = imtransform (..., PROP, VAL)
 -- Function File: [IM_OUT, XDATA, YDATA] = imtransform (...)
     Transform image.

     Given an image IM_IN, return an image IM_OUT resulting from the
     forward transform defined in the transformation structure T.  An
     additional input argument INTERP, 'bicubic', 'bilinear' (default)
     or 'nearest', specifies the interpolation method to be used.
     Finally, the transform can be tuned using PROP/VAL pairs.  The
     following properties PROP are supported:

     "udata"
          Specifies the input space horizontal limits.  VAL must be a
          two elements vector [minval maxval].  Default: [1
          columns(IM_IN)]

     "vdata"
          Specifies the input space vertical limits.  VAL must be a two
          elements vector [minval maxval].  Default: [1 rows(IM_IN)]

     "xdata"
          Specifies the required output space horizontal limits.  VAL
          must be a two elements vector [minval maxval].  Default:
          estimated using udata, vdata and findbounds function.

     "ydata"
          Specifies the required output space vertical limits.  VAL must
          be a two elements vector [minval maxval].  Default: estimated
          using udata, vdata and findbounds function.

     "xyscale"
          Specifies the size of pixels in the output space.  If a scalar
          is provided, both vertical and horizontal dimensions are
          scaled the same way.  If VAL is a two element vector, it must
          indicate consecutively width and height of the output pixels.
          The default is to use the width and height of input pixels
          provided that it does not lead to a too large output image.

     "size"
          Size of the output image (1-by-2 vector).  Overrides the
          effect of "xyscale" property.

     "fillvalues"
          Color of the areas where no interpolation is possible, e.g.
          when coordinates of points in the output space are out of the
          limits of the input space.  VAL must be coherent with the
          input image format: for grayscale and indexed images (2D) VAL
          must be scalar, for RGB (n-by-m-by-3) VAL must be a 3 element
          vector.

     The actual output limits, XDATA and YDATA vectors, are returned
     respectively as second and third output variables.

     See also: maketform, cp2tform, tforminv, tformfwd, findbounds.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 16
Transform image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
imtranslate


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 312
 -- Function File: Y = imtranslate (M, X, Y)
 -- Function File: Y = imtranslate (M, X, Y, BBOX)
     Translate a 2D image by (x,y) using Fourier interpolation.

     M is a matrix, and is translated to the right by X pixels and
     translated up by Y pixels.

     BBOX can be either 'crop' or 'wrap' (default).


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 58
Translate a 2D image by (x,y) using Fourier interpolation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
iptcheckmap


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 599
 -- Function File: iptcheckmap (IN, FUNC_NAME, VAR_NAME, POS)
     Check if argument is valid colormap.

     If IN is not a valid colormap, gives a properly formatted error
     message.  FUNC_NAME is the name of the function to be used on the
     error message, VAR_NAME the name of the argument being checked (for
     the error message), and POS the position of the argument in the
     input.

     A valid colormap is a 2-D matrix with 3 columns of doubles with
     values between 0 and 1 (inclusive), that refer to the intensity
     levels of red, green and blue.

     See also: colormap.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Check if argument is valid colormap.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
iptnum2ordinal


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 410
 -- Function File: ORD = iptnum2ordinal (NUM)
     Convert number to ordinal string.

     NUM must be a real positive integer which will be converted to a
     string with its ordinal form ORD.

          iptnum2ordinal (1)
                => first
          iptnum2ordinal (12)
               => twelfth
          iptnum2ordinal (21)
               => 21st

     See also: num2str, sprintf, int2str, mat2str.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Convert number to ordinal string.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
iradon


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2300
 -- Function File: RECON = iradon (PROJ, THETA, INTERP, FILTER, SCALING,
          OUTPUT_SIZE)

     Performs filtered back-projection on the projections in PROJ to
     reconstruct an approximation of the original image.

     PROJ should be a matrix whose columns are projections of an image
     (or slice).  Each element of THETA is used as the angle (in
     degrees) that the corresponding column of PROJ was projected at.
     If THETA is omitted, it is assumed that projections were taken at
     evenly spaced angles between 0 and 180 degrees.  THETA can also be
     a scalar, in which case it is taken as the angle between
     projections if more than one projection is provided.

     INTERP determines the type of interpolation that is used in the
     back-projection.  It must be one of the types accepted by
     'interp1', and defaults to 'Linear' if it is omitted.

     FILTER and SCALING determine the type of rho filter to apply.  See
     the help for 'rho_filter' for their use.

     OUTPUT_SIZE sets the edge length of the output image (it is always
     square).  This argument does not scale the image.  If it is
     omitted, the length is taken to be
     2 * floor (size (proj, 1) / (2 * sqrt (2))).

     If PROJ was obtained using 'radon', there is no guarantee that the
     reconstructed image will be exactly the same size as the original.

 -- Function File: [RECON, FILT] = iradon (...)

     This form also returns the filter frequency response in the vector
     FILT.

     Performs filtered back-projection in order to reconstruct an image
     based on its projections.

     Filtered back-projection is the most common means of reconstructing
     images from CT scans.  It is a two step process: First, each of the
     projections is filtered with a 'rho filter', so named due to its
     frequency domain definition, which is simply |rho|, where rho is
     the radial axis in a polar coordinate system.  Second, the filtered
     projections are each 'smeared' across the image space.  This is the
     back-projection part.

     Usage example:

            P = phantom ();
            projections = radon (P, 1:179);
            reconstruction = iradon (filtered_projections, 1:179, 'Spline', 'Hann');
            figure, imshow (reconstruction, [])


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Performs filtered back-projection on the projections in PROJ to
reconstruct an a



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
isbw


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 888
 -- Function File: isbw (IMG)
 -- Function File: isbw (IMG, LOGIC)
     Return true if IMG is a black and white image.

     A variable can be considered a black and white image if it is a
     non-sparse, real array of size MxNx1xK, and, depending on the value
     of LOGIC:

     "logical" (default)
          IMG must be of class logical.

     "non-logical"
          all values in IMG are either 1 or 0.

     _Note_: despite their suggestive names, the functions isbw, isgray,
     isind, and isrgb, are ambiguous since it is not always possible to
     distinguish between those image types.  For example: an uint8
     matrix can be both a grayscale and indexed image; a grayscale image
     may have values outside the range [0 1].  They are good to dismiss
     input as an invalid image type, but not for identification.

     See also: im2bw, isgray, isind, islogical, isrgb.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 46
Return true if IMG is a black and white image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 6
isgray


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 778
 -- Function File: isgray (IMG)
     Return true if IMG is a grayscale image.

     A variable can be considered a grayscale image if it is a
     non-sparse, real array of size MxNx1xK, and:

        * of floating point class with values in the [0 1] range or NaN;
        * of class uint8, uint16, or int16.

     _Note_: despite their suggestive names, the functions isbw, isgray,
     isind, and isrgb, are ambiguous since it is not always possible to
     distinguish between those image types.  For example: an uint8
     matrix can be both a grayscale and indexed image; a grayscale image
     may have values outside the range [0 1].  They are good to dismiss
     input as an invalid image type, but not for identification.

     See also: gray2ind, isbw, isind, isrgb.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Return true if IMG is a grayscale image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
isind


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 769
 -- Function File: isind (IMG)
     Return true if IMG is an indexed image.

     A variable can be considered an indexed image if it is a
     non-sparse, real array of size MxNx1xK, and:

        * of class double with all integers above zero;
        * of class uint8 or uint16.

     _Note_: despite their suggestive names, the functions isbw, isgray,
     isind, and isrgb, are ambiguous since it is not always possible to
     distinguish between those image types.  For example: an uint8
     matrix can be both a grayscale and indexed image; a grayscale image
     may have values outside the range [0 1].  They are good to dismiss
     input as an invalid image type, but not for identification.

     See also: ind2gray, ind2rgb, isbw, isgray, isindex, isrgb.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Return true if IMG is an indexed image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
isrgb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 775
 -- Function File: isrgb (IMG)
     Return true if IMG is a RGB image.

     A variable can be considered a RGB image if it is a non-sparse,
     real array of size MxNx3xK, and:

        * of floating point class with values in the [0 1] range or NaN;
        * of class uint8, uint16, or int16.

     _Note_: despite their suggestive names, the functions isbw, isgray,
     isind, and isrgb, are ambiguous since it is not always possible to
     distinguish between those image types.  For example: an uint8
     matrix can be both a grayscale and indexed image; a grayscale image
     may have values outside the range [0 1].  They are good to dismiss
     input as an invalid image type, but not for identification.

     See also: rgb2gray, rgb2ind, isbw, isgray, isind.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Return true if IMG is a RGB image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
lab2double


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 543
 -- Function File: lab2double (LAB)
     Convert L*a*b* data to double precision.

     LAB must be a L*a*b* image or colormap, i.e., its dimensions must
     be MxNx3xK or Mx3.  Its type must be double, single, uint16, or
     uint8.

     When converted to double, L* values range from 0 to 100, while a*
     and b* range from -128 to 127.  When converting from uint16, the
     upper limit is 65280 (higher values will be converted above the
     range).

     See also: lab2double, lab2rgb, lab2single, lab2uint8, lab2uin16,
     lab2xyz.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Convert L*a*b* data to double precision.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
lab2rgb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1217
 -- Function File: RGB = lab2rgb (LAB)
 -- Function File: RGB_MAP = lab2rgb (LAB_MAP)
     Transform a colormap or image from CIE L*a*b* to sRGB color space.

     A color in the CIE L*a*b* (or CIE Lab) space consists of lightness
     L* and two color-opponent dimensions a* and b*.  The whitepoint is
     taken as D65.  The CIE L*a*b* colorspace is a colorimetric
     colorspace.  It is additionally designed to incorporate the human
     perception of color differences.

     A color in the RGB space consists of red, green, and blue
     intensities.  The input RGB values are interpreted as nonlinear
     sRGB values with the white point D65.  This means the input values
     are assumed to be in a colorimetric (sRGB) colorspace.

     Input values of class single and double are accepted.  The shape
     and the class of the input are conserved.

     The input values of L* are normally in the inteval [0, 100] and the
     values of a* and b* in the interval [-127, 127].

     note: This function returns slightly different values than the
     Matlab version.  But it has a better "round trip accuracy" (<2e-5)
     for RGB -> Lab -> RGB.

     See also: rgb2lab, rgb2xyz, rgb2hsv, rgb2ind, rgb2ntsc.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Transform a colormap or image from CIE L*a*b* to sRGB color space.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
lab2single


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 543
 -- Function File: lab2double (LAB)
     Convert L*a*b* data to single precision.

     LAB must be a L*a*b* image or colormap, i.e., its dimensions must
     be MxNx3xK or Mx3.  Its type must be double, single, uint16, or
     uint8.

     When converted to single, L* values range from 0 to 100, while a*
     and b* range from -128 to 127.  When converting from uint16, the
     upper limit is 65280 (higher values will be converted above the
     range).

     See also: lab2double, lab2rgb, lab2single, lab2uint8, lab2uin16,
     lab2xyz.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Convert L*a*b* data to single precision.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
lab2uint16


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 504
 -- Function File: lab2double (LAB)
     Convert L*a*b* data to uint16 precision.

     LAB must be a L*a*b* image or colormap, i.e., its dimensions must
     be MxNx3xK or Mx3.  Its type must be double, single, uint16, or
     uint8.

     When converted from double or single, L* values usually range from
     0 to 100, while a* and b* range from -128 to 127.  The upper limit
     values will be converted to 65280.

     See also: lab2double, lab2rgb, lab2single, lab2uint8, lab2uin16,
     lab2xyz.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 40
Convert L*a*b* data to uint16 precision.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
lab2uint8


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 491
 -- Function File: lab2double (LAB)
     Convert L*a*b* data to uint8 precision.

     LAB must be a L*a*b* image or colormap, i.e., its dimensions must
     be MxNx3xK or Mx3.  Its type must be double, single, uint16, or
     uint8.

     When converted from double or single, L* values must range from 0
     to 100, while a* and b* range from -128 to 127.  Values outside
     this range will be capped.

     See also: lab2double, lab2rgb, lab2single, lab2uint8, lab2uin16,
     lab2xyz.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Convert L*a*b* data to uint8 precision.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
lab2xyz


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1002
 -- Function File: XYZ = lab2xyz (LAB)
 -- Function File: XYZ_MAP = lab2xyz (LAB_MAP)
     Transform a colormap or image from CIE L*a*b* to CIE XYZ color
     space.

     A color in the CIE L*a*b* (or CIE Lab) space consists of lightness
     L* and two color-opponent dimensions a* and b*.  The whitepoint is
     taken as D65.  The CIE L*a*b* colorspace is a colorimetric
     colorspace, meaning that their values do not depend on the display
     device hardware.  This colorspace is designed to incorporate the
     human perception of color differences.

     A color in the CIE XYZ color space consists of three values X, Y
     and Z. Those values are also designed to be colorimetric.

     Input values of class single and double are accepted.  The shape
     and the class of the input are conserved.

     The input values of L* are normally in the inteval [0, 100] and the
     values of a* and b* in the interval [-127, 127].

     See also: xyz2lab, rgb2lab, rgb2hsv, rgb2ind, rgb2ntsc.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Transform a colormap or image from CIE L*a*b* to CIE XYZ color space.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
label2rgb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1407
 -- Function File: label2rgb (L)
 -- Function File: label2rgb (L, CMAP)
 -- Function File: label2rgb (L, CMAP, BACKGROUND)
 -- Function File: label2rgb (L, CMAP, BACKGROUND, ORDER)
     Convert labeled image into RGB.

     The labeled image L is converted into an RGB image using the
     colormap CMAP.  The label number of each region is used to select
     the color from CMAP which can be specified as:

        * N-by-3 colormap matrix where N must be larger than or equal to
          the highest label number;
        * name of a function that returns a colormap;
        * handle for a function that returns a colormap (defaults to
          'jet').

     In a labeled image, zero valued pixels are considered background
     and are colored according to the color BACKGROUND.  It can be
     specified as an RGB triplet values (3 element vector of values
     between 0 and 1), or by name:

        * "w" or "white" (default)
        * "b" or "blue".
        * "c" or "cyan".
        * "g" or "green".
        * "k" or "black".
        * "m" or "magenta".
        * "r" or "red".
        * "y" or "yellow".

     The option ORDER must be a string with values "shuffle" or
     "noshuffle" (default).  If shuffled, the colors in CMAP are
     permuted randomly before the image conversion.

     The output RGB image is always of class uint8.

     See also: bwconncomp, bwlabel, colormap, ind2rgb.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Convert labeled image into RGB.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
labelmatrix


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 515
 -- Function File: labelmatrix (CC)
     Create labelled matrix from bwconncomp structure.

     Uses the structure as returned by the 'bwconncomp' function to
     create a label matrix, where each individual object is assigned a
     positive number.  A value of zero corresponds to the background.

     The class of the output matrix is dependent on the number of
     objects, being uint, uint16, uint32, or double, whichever is
     enough.

     See also: bwconncomp, bwlabel, bwlabeln, label2rgb, rgb2label.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 49
Create labelled matrix from bwconncomp structure.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
makelut


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 823
 -- Function File: LUT = makelut (FUN, N)
 -- Function File: LUT = makelut (FUN, N, P1, P2, ...)
     Create a lookup table which can be used by applylut.

     lut = makelut(fun,n) returns a vector which can be used by applylut
     as a lookup table.

     FUN can be a function object as created by inline, or simply a
     string which contains the name of a function.  FUN should accept a
     N-by-N matrix whose elements are binary (0 or 1) and returns an
     scalar (actually anything suitable to be included in a vector).

     makelut calls FUN with all possible matrices and builds a vector
     with its result, suitable to be used by applylut.  The length of
     this vector is 2^(N^2), so 16 for 2-by-2 and 512 for 3-by-3.

     makelut also passes parameters P1, P2, ....  to FUN.

     See also: applylut.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 52
Create a lookup table which can be used by applylut.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
maketform


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 3217
 -- Function File: T = maketform (TTYPE, TMAT)
 -- Function File: T = maketform (TTYPE, INC, OUTC)
 -- Function File: T = maketform ("custom", NDIMS_IN, NDIMS_OUT,
          FORWARD_FCN, INVERSE_FCN, TDATA)
     Create a transform structure T to be used for spatial
     transformations between an input space and an output space.

     The fields of the transform structure are:

     "ndims_in", "ndims_out": the number of
          dimensions of the input and output space.

     "forward_fcn", "inverse_fcn": the callback
          functions that are called for forward (input to output) and
          inverse transform.

     "tdata": an inverse transform matrix or a structure
          containing forward and inverse transform matrices.

     The content of each field depends on the requested transform type
     TTYPE:

     "projective"
          A ndims_in = ndims_out = N projective transform structure is
          returned.  If a second input argument TMAT is provided, it
          must be a (N+1)-by-(N+1) inverse transformation matrix.  The
          (N+1)th column must contain projection coefficients.  As an
          example a two dimensional inverse transform from [x y]
          coordinates to [u v] coordinates is represented by an inverse
          transformation matrix defined so that:

               [xx yy zz] = [u v 1] * [a d g;
                                       b e h;
                                       c f i]
               [x y] =  [xx./zz yy./zz];

          Alternatively the transform can be specified using the
          coordinates of a quadrilateral (typically the 4 corners of the
          image) in the input space (INC, 4-by-ndims_in matrix) and in
          the output space (OUTC, 4-by-ndims_out matrix).  This is
          equivalent to building the transform using 'T = cp2tform (INC,
          OUTC, "projective")'.

     "affine"
          Affine is a subset of projective transform (see above).  A
          ndims_in = ndims_out = N affine transformation structure is
          returned.  If a second input argument TMAT is provided, it
          must be a (N+1)-by-(N+1) or (N+1)-by-(N) transformation
          matrix.  If present, the (N+1)th column must contain
          [zeros(N,1); 1] so that projection is suppressed.

          Alternatively the transform can be specified using the
          coordinates of a triangle (typically 3 corners of the image)
          in the input space (INC, 3-by-ndims_in matrix) and in the
          output space (OUTC, 3-by-ndims_out matrix).  This is
          equivalent to building the transform using 'T = cp2tform (INC,
          OUTC, "affine")'.

     "custom"
          For user defined transforms every field of the transform
          structure must be supplied.  The prototype of the transform
          functions, FORWARD_FCN and INVERSE_FCN, should be X' =
          transform_fcn (X, T). X and X' are respectively p-by-ndims_in
          and p-by-ndims_out arrays for forward_fcn and reversed for
          inverse_fcn.  The argument T is the transformation structure
          which will contain the user supplied transformation matrix
          TDATA.

     See also: tformfwd, tforminv, cp2tform.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Create a transform structure T to be used for spatial transformations
between an



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
mat2gray


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1187
 -- Function File: I = mat2gray (M)
 -- Function File: I = mat2gray (M, [MIN MAX])
     Convert a matrix to an intensity image.

     The returned matrix I is a grayscale image, of double class and in
     the range of values [0, 1].  The optional arguments MIN and MAX
     will set the limits of the conversion; values in M below MIN and
     above MAX will be set to 0 and 1 on I respectively.

     MAX and MIN default to the maximum and minimum values of M.

     If MIN is larger than MAX, the 'inverse' will be returned.  Values
     in M above MAX will be set to 0 while the ones below MIN will be
     set to 1.

     *Caution:* For compatibility with MATLAB, if MIN and MAX are equal
     (either from being actually being set manually or automatically
     calculated from the M min and max values, Octave's mat2gray will
     truncate all values between [0 1].  For example

          mat2gray ([-2 0 0.5 0.9 5], [2 2])
               => [0  0  0.5  0.9  1]
          mat2gray ([0.5 0.5 0.5])
               => [0.5  0.5  0.5]
          mat2gray ([4 4 4])
               => [1  1  1]

     See also: gray2ind, ind2gray, rgb2gray, im2double, im2uin16,
     im2uint8, im2int16.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 39
Convert a matrix to an intensity image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
mean2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 369
 -- Function File: mean2 (I)
     Compute mean value of array.

     While the function name suggests that it computes the mean value of
     a 2D array, it will actually computes the mean value of an entire
     array.  It is equivalent to 'mean (I(:))'.

     The return value will be of class double independently of the input
     class.

     See also: mean, std2.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Compute mean value of array.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
medfilt2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1061
 -- Function File: medfilt2 (A)
 -- Function File: medfilt2 (A, NHOOD)
 -- Function File: medfilt2 (A, [M N])
 -- Function File: medfilt2 (..., PAD)
     Two dimensional median filtering.

     Replaces elements of A with the median of their neighbours as
     defined by the true elements of logical matrix NHOOD or by a matrix
     of size M by N.  The default NHOOD is a 3 by 3 matrix of true
     elements.

          ## median filtering specifying neighborhood dimensions
          medfilt2 (img)         # default is [3 3]
          medfilt2 (img, [3 1])  # a 3x1 vector
          medfilt2 (img, [5 5])  # 5 element wide square

          ## median filtering specifying neighborhood
          medfilt2 (img, true (5)) # same as [5 5]
          nhood = logical ([0 1 0
                            1 1 1
                            0 1 0]);
          medfilt2 (img, nhood)    # 3 element wide cross

     The optional variable PAD defines the padding used in augmenting
     the borders of A.  See 'padarray' for details.

     See also: ordfilt2, ordfiltn.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Two dimensional median filtering.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
mmgradm


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1186
 -- Function File: mmgradm (IMG)
 -- Function File: mmgradm (IMG, SE_DIL)
 -- Function File: mmgradm (IMG, SE_DIL, SE_ERO)
     Perform morphological gradient.

     The matrix IMG must be numeric whose gradients is calculated, while
     SE_DIL and SE_ERO are the structuring elements for the dilation and
     erosion respectively.  They can be a:
        * strel object;
        * array of strel objects as returned by '@strel/getsequence';
        * matrix of 0's and 1's.

     The SE_DIL and SE_ERO default to the elementary cross, i.e.:
          [ 0 1 0
            1 1 1
            0 1 0];

     The basic morphological gradient corresponds to a matrix erosion
     subtracted to its dilation, which is equivalent to:
          imdilate (img, se_dil) - imerode (img, se_ero)

     To perform the half-gradients by erosion or dilation, or the
     internal or external gradients, simply pass an empty matrix as
     structuring element:
          mmgradm (img, [], se_ero) # half-gradient by erosion or internal gradient
          mmgradm (img, se_dil, []) # half-gradient by dilation or external gradient

     See also: imerode, imdilate, imopen, imclose, imtophat, imbothat.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 31
Perform morphological gradient.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
montage


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2145
 -- Function File: montage (I)
 -- Function File: montage (X, CMAP)
 -- Function File: montage (FILENAMES)
 -- Function File: montage (..., PARAM1, VALUE1, ...)
 -- Function File: H = montage (...)
     Create montage from multiple images.

     The created montage will be of a single large image built from the
     4D matrix I.  I must be a MxNx1xP or MxNx3xP matrix for a grayscale
     and binary, or RGB image with P frames.

     Alternatively, X can be a MxNx1xP indexed image with P frames, with
     the colormap CMAP, or a cell array of FILENAMES for multiple
     images.

     DisplayRange
          A vector with 2 or 0 elements setting the highest and lowest
          value for display range.  It is interpreted like the LIMITS
          argument to 'imshow'.  Of special significance is that an
          empty array uses the image minimum and maximum values for
          limits.  Defaults to the limits of the image data type, i.e.,
          the range returned by 'getrangefromclass'.

     Indices
          A vector with the image indices to be displayed.  Defaults to
          all images, i.e., '1:size (I, 4)'.

     Size
          Sets the montage layout size.  Must be a 2 element vector
          setting [NROWS NCOLS].  A value of NaN will be adjusted to the
          required value to display all images.  If both values are NaN
          (default), it will find the most square layout capable of
          displaying all of the images.

     MarginColor
          Sets color for the margins between panels.  Defaults to white.
          Must be a 1 or 3 element vector for grayscale or RGB images.

     MarginWidth
          Sets width for the margins between panels.  Defaults to 0
          pixels.  Note that the margins are only between panels.

     BackgroundColor
          Sets the montage background color.  Defaults to black.  Must
          be a 1 or 3 element vector for grayscale or RGB images.  This
          will only affect montages with more panels than images.

     The optional return value H is a graphics handle to the created
     plot.

     See also: imshow, padarray, permute, reshape.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Create montage from multiple images.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
nlfilter


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1831
 -- Function File: nlfilter (A, BLOCK_SIZE, FUNC)
 -- Function File: nlfilter (A, BLOCK_SIZE, FUNC, ...)
 -- Function File: nlfilter (A, "indexed", ...)
     Process matrix in sliding blocks with user-supplied function.

     Executes the function FUN on each sliding block of size BLOCK_SIZE,
     taken from the matrix A.  Both the matrix A, and the block can have
     any number of dimensions.  This function is specially useful to
     perform sliding/moving window functions such as moving average.

     The output will have the same dimensions A, each one of its values
     corresponding to the processing of a block centered at the same
     coordinates in A, with A being padded with zeros for the borders
     (see below for indexed images).  In case any side of the block is
     of even length, the center is considered at indices 'floor
     ([BLOCK_SIZE/2] + 1)'.

     The argument FUNC must be a function handle that takes matrices of
     size BLOCK_SIZE as input and returns a single scalar.  Any extra
     input arguments to 'nlfilter' are passed to FUNC after the block
     matrix.

     If A is an indexed image, the second argument should be the string
     "indexed" so that any required padding is done correctly as done by
     'im2col'.

     _Note_: if FUNC is a column compression function, i.e., it acts
     along a column to return a single value, consider using 'colfilt'
     which usually performs faster.  If FUNC makes use of the colon
     operator to select all elements in the block, e.g., if FUNC looks
     anything like '@(x) sum (x(:))', it is a good indication that
     'colfilt' should be used.  In addition, many sliding block
     operations have their own specific implementations (see help text
     of 'colfilt' for a list).

     See also: blockproc, col2im, colfilt, im2col.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 61
Process matrix in sliding blocks with user-supplied function.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
normxcorr2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1023
 -- Function File: normxcorr2 (TEMPLATE, IMG)
     Compute normalized cross-correlation.

     Returns the cross-correlation coefficient of matrices TEMPLATE and
     IMG, a matrix of (roughly) the same size as IMG with values ranging
     between -1 and 1.

     Normalized correlation is mostly used for template matching,
     finding an object or pattern, TEMPLATE, withing an image IMG.
     Higher values on the output show their locations, even in the
     presence of noise.

          img = randi (255, 600, 400);
          template = imnoise (img(100:150, 300:320), "gaussian");
          cc = normxcorr2 (template, img);
          [r, c] = find (cc == max (cc(:)))
          => 150
          => 320

     Despite the function name, this function will accept input with an
     arbitrary number of dimensions.

     Note that the size of the cross-correlation array is slightly
     bigger than IMG because the input image is padded during the
     calculation.

     See also: conv2, convn, corr2, xcorr, xcorr2.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 37
Compute normalized cross-correlation.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ordfilt2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 426
 -- Function File: ordfilt2 (A, NTH, DOMAIN)
 -- Function File: ordfilt2 (A, NTH, DOMAIN, S)
 -- Function File: ordfilt2 (..., PADDING)
     Two dimensional ordered filtering.

     This function exists only for MATLAB compatibility as is just a
     wrapper to the 'ordfiltn' which performs the same function on N
     dimensions.  See 'ordfiltn' help text for usage explanation.

     See also: medfilt2, padarray, ordfiltn.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Two dimensional ordered filtering.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
ordfiltn


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 797
 -- Function File: ordfiltn (A, NTH, DOMAIN)
 -- Function File: ordfiltn (A, NTH, DOMAIN, S)
 -- Function File: ordfiltn (..., PADDING)
     N dimensional ordered filtering.

     Ordered filter replaces an element of A with the NTH element
     element of the sorted set of neighbours defined by the logical
     (boolean) matrix DOMAIN.  Neighbour elements are selected to the
     sort if the corresponding element in the DOMAIN matrix is true.

     The optional variable S is a matrix of size(DOMAIN).  Values of S
     corresponding to nonzero values of domain are added to values
     obtained from A when doing the sorting.

     Optional variable PADDING determines how the matrix A is padded
     from the edges.  See 'padarray' for details.

     See also: medfilt2, padarray, ordfilt2.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
N dimensional ordered filtering.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
otf2psf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 314
 -- Function File: otf2psf (OTF)
 -- Function File: otf2psf (OTF, OUTSIZE)
     Compute PSF from OTF.

     Returns the Point Spread Function (OTF) of the Optical Transfer
     Function OTF.

     The optional argument OUTSIZE defines the size of the returned PSF.

     See also: circshift, ifft2, ifftn, psf2otf.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
Compute PSF from OTF.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
padarray


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2061
 -- Function File: padarray (A, PADSIZE)
 -- Function File: padarray (..., PADVAL)
 -- Function File: padarray (..., PATTERN)
 -- Function File: padarray (..., DIRECTION)
     Pad array or matrix.

     Adds padding of length PADSIZE, to a numeric matrix A.  PADSIZE
     must be a vector of non-negative values, each of them defining the
     length of padding to its corresponding dimension.  For example, if
     PADSIZE is [4 5], it adds 4 rows (1st dimension) and 5 columns (2nd
     dimension), to both the start and end of A.

     If there's less values in PADSIZE than number of dimensions in A,
     they're assumed to be zero.  Singleton dimensions of A are also
     padded accordingly (except when PATTERN is "reflect").

     The values used in the padding can either be a scalar value PADVAL,
     or the name of a specific PATTERN.  Available patterns are:

     "zeros" (default)
          Pads with the value 0 (same as passing a PADVAL of 0).  This
          is the default.

     "circular"
          Pads with a circular repetition of elements in A (similar to
          tiling A).

     "replicate"
          Pads replicating the values at the border of A.

     "symmetric"
          Pads with a mirror reflection of A.

     "reflect"
          Same as "symmetric", but the borders are not used in the
          padding.  Because of this, it is not possible to pad singleton
          dimensions.

     By default, padding is done in both directions.  To change this,
     DIRECTION can be one of the following values:

     "both" (default)
          Pad each dimension before the first element of A the number of
          elements defined by PADSIZE, and the same number again after
          the last element.  This is the default.

     "pre"
          Pad each dimension before the first element of A the number of
          elements defined by PADSIZE.

     "post"
          Pad each dimension after the last element of A the number of
          elements defined by PADSIZE.

     See also: cat, flipdim, resize, prepad, postpad.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 20
Pad array or matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
phantom


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2553
 -- Function File: P = phantom ()
 -- Function File: P = phantom (MODEL)
 -- Function File: P = phantom (E)
 -- Function File: P = phantom (..., N)
 -- Function File: [P, E] = phantom (...)
     Create computational phantom head.

     A phantom is a known object (either real or purely mathematical)
     that is used for testing image reconstruction algorithms.  The
     Shepp-Logan phantom is a popular mathematical model of a cranial
     slice, made up of a set of overlaying ellipses.  This allows
     rigorous testing of computed tomography (CT) algorithms as it can
     be analytically transformed with the radon transform (see the
     functions 'radon' and 'iradon').

     The phantom P, is created by overlaying ellipses as defined by the
     matrix E or one of the standard MODELs, in a square of size N by N
     (defaults to 256).

     The available standard MODELs (use the output argument E to inspect
     the details of the different ellipses) are:

     "Shepp-Logan"
          This is the original Shepp-Logan model with 10 ellipses as
          described in Table 1 of 'Shepp, Lawrence A., and Benjamin F.
          Logan. "The Fourier reconstruction of a head section." Nuclear
          Science, IEEE Transactions on 21, no. 3 (1974): 21-43.'

     "Modified Shepp-Logan" (default)
          A modification of the original Shepp-Logan model to give a
          better contrast, as described in Table B.3 of 'Toft, Peter
          Aundal. "The radon transform-theory and implementation." PhD
          diss., Department of Mathematical Modelling, Technical
          University of Denmark, 1996.'

     A 6 column matrix E can be used to generate a custom image by
     superimposing arbitrary ellipses.  Each row defines a single
     ellipse, with each column for the values of {I, a, b, x0, y0, phi}:

     I
          is the additive intensity of the ellipse

     a
          is the length of the major axis

     b
          is the length of the minor axis

     x0
          is the horizontal offset of the centre of the ellipse

     y0
          is the vertical offset of the centre of the ellipse

     phi
          is the counterclockwise rotation of the ellipse in degrees,
          measured as the angle between the x axis and the ellipse major
          axis.

     The image bounding box in the algorithm is {[-1, -1], [1, 1]}, so
     the values of a, b, x0, y0 should all be specified with this in
     mind.

     Example:

          P = phantom (512);
          imshow (P);

     See also: iradon, radon.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 34
Create computational phantom head.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
poly2mask


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1182
 -- Function File: BW = poly2mask (X,Y,M,N)
     Convert a polygon to a region mask.

     BW=poly2mask(x,y,m,n) converts a polygon, specified by a list of
     vertices in X and Y and returns in a M-by-N logical mask BW the
     filled polygon.  Region inside the polygon is set to 1, values
     outside the shape are set to 0.

     X and Y should always represent a closed polygon, first and last
     points should be coincident.  If they are not poly2mask will close
     it for you.  If X or Y are fractional they are nearest integer.

     If all the polygon or part of it falls outside the masking area
     (1:m,1:n), it is discarded or clipped.

     This function uses scan-line polygon filling algorithm as described
     in http://www.cs.rit.edu/~icss571/filling/ with some minor
     modifications: capability of clipping and scan order, which can
     affect the results of the algorithm (algorithm is described not to
     reach ymax, xmax border when filling to avoid enlarging shapes).
     In this function we scan the image backwards (we begin at ymax and
     end at ymin), and we don't reach ymin, xmin, which we believe
     should be compatible with MATLAB.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Convert a polygon to a region mask.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
psf2otf


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 395
 -- Function File: psf2otf (PSF)
 -- Function File: psf2otf (PSF, OUTSIZE)
     Compute OTF from PSF.

     Returns the Optical Transfer Function (OTF) of the Point Spread
     Function PSF.

     The optional argument OUTSIZE defines the size of the computed OTF.
     The input PSF is post-padded with zeros previous to the OTF
     computation.

     See also: circshift, fft2, fftn, otf2psf.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 21
Compute OTF from PSF.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
psnr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 539
 -- Function File: [PEAKSNR] = psnr (A, REF)
 -- Function File: [PEAKSNR] = psnr (A, REF, PEAK)
 -- Function File: [PEAKSNR, SNR] = psnr (...)
     Compute peak signal-to-noise ratio.

     Computes the peak signal-to-noise ratio for image A, using REF as
     reference.  A and REF must be of same size and class.

     The optional value PEAK defines the highest value for the image and
     its default is class dependent (see 'getrangefromclass').

     The second output SNR is the simple signal-to-noise ratio.

     See also: immse.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Compute peak signal-to-noise ratio.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
qtdecomp


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2392
 -- Function File: S = qtdecomp (I)
 -- Function File: S = qtdecomp (I, THRESHOLD)
 -- Function File: S = qtdecomp (I, THRESHOLD, MINDIM)
 -- Function File: S = qtdecomp (I, THRESHOLD, [MINDIM MAXDIM])
 -- Function File: S = qtdecomp (I, FUN)
 -- Function File: S = qtdecomp (I, FUN, P1, P2, ...)
     Performs quadtree decomposition.

     qtdecomp decomposes a square image I into four equal-sized blocks.
     Then it performs some kind of test on each block to decide if it
     should decompose them further.  This process is repeated
     iteratively until there's no block left to be decomposed.

     Note that blocks are not decomposed if their dimensions are not
     even.

     The output is a sparse matrix whose non-zero elements determine the
     position of the block (the element is at top-left position in the
     block) and size of each block (the value of the element determines
     length of a side of the square-shaped block).

     S = qtdecomp(I) decomposes an intensity image I as described above.
     By default it doesn't split a block if all elements are equal.

     S = qtdecomp(I, threshold) decomposes an image as described, but
     only splits a block if the maximum value in the block minus the
     minimum value is greater than THRESHOLD, which is a value between 0
     and 1.  If I is of class uint8, THRESHOLD is multiplied by 255
     before use.  Also, ifI is of class uint16, THRESHOLD is multiplied
     by 65535.

     S = qtdecomp(I, threshold, mindim) decomposes an image using the
     THRESHOLD as just described, but doesn't produce blocks smaller
     than mindim.

     S = qtdecomp(I, threshold, [mindim maxdim]) decomposes an image as
     described, but produces blocks that can't be bigger than maxdim.
     It decomposes to maxdim even if it isn't needed if only THRESHOLD
     was considered.

     S = qtdecomp(I, fun) decomposes an image I and uses function FUN to
     decide if a block should be splitted or not.  FUN is called with a
     m-by-m-by-k array of m-by-m blocks to be considered, and should
     return a vector of size k, whose elements represent each block in
     the stacked array.  FUN sets the corresponding value to 1 if the
     block should be split, and 0 otherwise.

     S = qtdecomp(I, fun, ...) behaves as qtdecomp(I, fun) but passes
     extra parameters to FUN.

     See also: qtgetblk, qtsetblk.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 32
Performs quadtree decomposition.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
qtgetblk


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 906
 -- Function File: [VALS] = qtgetblk (I, S, DIM)
 -- Function File: [VALS,IDX] = qtgetblk (I, S, DIM)
 -- Function File: [VALS,R,C] = qtgetblk (I, S, DIM)
     Obtain block values from a quadtree decomposition.

     [vals]=qtgetblk(I,S,dim) returns a dim-by-dim-by-k array in VALS
     which contains the dim-by-dim blocks in the quadtree decomposition
     (S, which is returned by qtdecomp) of I.  If there are no blocks,
     an empty matrix is returned.

     [vals,idx]=qtgetblk(I,S,dim) returns VALS as described above.  In
     addition, it returns IDX, a vector which contains the linear
     indices of the upper left corner of each block returned (the same
     result as find(full(S)==dim)).

     [vals,r,c]=qtgetblk(I,S,dim) returns VALS as described, and two
     vectors, R and C, which contain the row and column coordinates of
     the blocks returned.

     See also: qtdecomp, qtsetblk.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 50
Obtain block values from a quadtree decomposition.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
qtsetblk


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 413
 -- Function File: J = qtsetblk (I, S, DIM, VALS)
     Set block values in a quadtree decomposition.

     J=qtsetblk(I,S,dim,vals) sets all the DIM-by-DIM blocks in the
     quadtree decomposition (S returned by qtdecomp) of I to DIM-by-DIM
     blocks in VALS, which is itself a DIM-by-DIM-by-k array.  k is the
     number of DIM-by-DIM blocks in the quadtree decomposition.

     See also: qtdecomp, qtgetblk.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 45
Set block values in a quadtree decomposition.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 5
radon


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 346
 -- Function File: [RT,XP] = radon(I, THETA)
 -- Function File: [RT,XP] = radon(I)

     Calculates the 2D-Radon transform of the matrix I at angles given
     in THETA.  To each element of THETA corresponds a column in RT.
     The variable XP represents the x-axis of the rotated coordinate.
     If THETA is not defined, then 0:179 is assumed.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 75
Calculates the 2D-Radon transform of the matrix I at angles given in
THETA.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
rangefilt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 866
 -- Function File: R = rangefilt (IM)
 -- Function File: R = rangefilt (IM, DOMAIN)
 -- Function File: R = rangefilt (IM, DOMAIN, PADDING, ...)
     Computes the local intensity range in a neighbourhood around each
     pixel in an image.

     The intensity range of the pixels of a neighbourhood is computed as

          R = max (X) - min (X)

     where X is the value of the pixels in the neighbourhood,

     The neighbourhood is defined by the DOMAIN binary mask.  Elements
     of the mask with a non-zero value are considered part of the
     neighbourhood.  By default a 3 by 3 matrix containing only non-zero
     values is used.

     At the border of the image, extrapolation is used.  By default
     symmetric extrapolation is used, but any method supported by the
     'padarray' function can be used.

     See also: paddarray, entropyfilt, stdfilt.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Computes the local intensity range in a neighbourhood around each pixel
in an im



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 11
regionprops


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7187
 -- Function File: regionprops (BW)
 -- Function File: regionprops (L)
 -- Function File: regionprops (CC)
 -- Function File: regionprops (..., PROPERTIES)
 -- Function File: regionprops (..., I, PROPERTIES)
     Compute properties of image regions.

     Measures several properties for each region within an image.
     Returns a struct array, one element per region, whose field names
     are the measured properties.

     Individual regions can be defined in three different ways, a binary
     image, a labelled image, or a bwconncomp struct, each providing
     different advantages.

     BW
          A binary image.  Must be of class logical.  Individual regions
          will be the connected component as computed by 'bwconnmp'
          using the maximal connectivity for the number of dimensions of
          BW (see 'conndef' for details).  For alternative
          connectivities, call 'bwconncomp' directly and use its output
          instead.

          BW must really be of class logical.  If not, even if it is a
          numeric array of 0's and 1's, it will be treated as a labelled
          image with a single discontinuous region.  For example:

               ## Handled as binary image with 3 regions
               bw = logical ([
                 1 0 1 0 1
                 1 0 1 0 1
               ]);

               ## Handled as labelled image with 1 region
               bw = [
                 1 0 1 0 1
                 1 0 1 0 1
               ];

     L
          A labelled image.  Each region is the collection of all
          positive elements with the same value.  This allows computing
          properties of regions that would otherwise be considered
          separate or connected.  For example:

               ## Recognizes 4 regions
               l = [
                 1 2 3 4
                 1 2 3 4
               ];

               ## Recognizes 2 (discontinuous) regions
               l = [
                 1 2 1 2
                 1 2 1 2
               ];

     CC
          A 'bwconnmp()' structure.  This is a struct with the following
          4 fields: Connectivity, ImageSize, NumObjects, and
          PixelIdxList.  See 'bwconncomp' for details.

     The properties to be measured can be defined via a cell array or a
     comma separated list or strings.  Some of the properties are only
     supported if the matching grayscale image I is also supplied.
     Others are only supported for 2 dimensional images.  See the list
     below for details on each property limitation.  If none is
     specified, it defaults to the "basic" set of properties.

     "Area"
          The number of pixels in the region.  Note that this differs
          from 'bwarea' where each pixel has different weights.

     "BoundingBox"
          The smalles rectangle that encloses the region.  This is
          represented as a row vector such as '[x y z ... x_length
          y_length z_length ...]'.

          The first half corresponds to the lower coordinates of each
          dimension while the second half, to the length in that
          dimension.  For the two dimensional case, the first 2 elements
          correspond to the coordinates of the upper left corner of the
          bounding box, while the two last entries are the width and the
          height of the box.

     "Centroid"
          The coordinates for the region centre of mass.  This is a row
          vector with one element per dimension, such as '[x y z ...]'.

     "Eccentricity"
          The eccentricity of the ellipse that has the same normalized
          second central moments as the region (value between 0 and 1).

     "EquivDiameter"
          The diameter of a circle with the same area as the object.

     "EulerNumber"
          The Euler number of the region using connectivity 8.  Only
          supported for 2D images.  See 'bweuler' for details.

     "Extent"
          The area of the object divided by the area of the bounding
          box.

     "Extrema"
          Returns an 8-by-2 matrix with the extrema points of the
          object.  The first column holds the returned x- and the second
          column the y-values.  The order of the 8 points is: top-left,
          top-right, right-top, right-bottom, bottom-right, bottom-left,
          left-bottom, left-top.

     "FilledArea"
          The area of the object including possible holes.

     "FilledImage"
          A binary image with the same size as the object's bounding box
          that contains the object with all holes removed.

     "Image"
          An image with the same size as the bounding box that contains
          the original pixels.

     "MajorAxisLength"
          The length of the major axis of the ellipse that has the same
          normalized second central moments as the object.

     "MaxIntensity"
          The maximum intensity value inside each region.  Requires a
          grayscale image I.

     "MeanIntensity"
          The mean intensity value inside each region.  Requires a
          grayscale image I.

     "MinIntensity"
          The minimum intensity value inside each region.  Requires a
          grayscale image I.

     "MinorAxisLength"
          The length of the minor axis of the ellipse that has the same
          normalized second central moments as the object.

     "Orientation"
          The angle between the x-axis and the major axis of the ellipse
          that has the same normalized second central moments as the
          object (value in degrees between -90 and 90).

     "Perimeter"
          The length of the boundary of the object.

     "PixelIdxList"
          The linear indices for the elements of each region in a column
          vector.

     "PixelList"
          The subscript indices for the elements of each region.  This
          is a p-by-Q matrix where p is the number of elements and Q is
          the number of dimensions.  Each row is of the form '[x y z
          ...]'.

     "PixelValues"
          The actual pixel values inside each region in a column vector.
          Requires a grayscale image I.

     "SubarrayIdx"
          A cell array with subscript indices for the bounding box.
          This can be used as 'I(PROPS(P).SubarrayIdx{:})', where P is
          one of the regions, to extract the image in its bounding box.

     "WeightedCentroid"
          The coordinates for the region centre of mass when using the
          intensity of each element as weight.  This is a row vector
          with one element per dimension, such as '[x y z ...]'.
          Requires a grayscale image I.

     In addition, the strings "basic" and "all" can be used to select a
     subset of the properties:

     "basic" (default)
          Compute "Area", "Centroid", and "BoundingBox".

     "all"
          Computes all possible properties for the image, i.e., it will
          not compute properties that require grayscale unless the
          grayscale image is available, and it will not compute
          properties that are limited to 2 dimensions, unless the image
          is 2 dimensions.

     See also: bwlabel, bwperim, bweuler.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 36
Compute properties of image regions.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
rgb2gray


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 475
 -- Function File: GRAY= rgb2gray (RGB)
     Convert RGB image or colormap to grayscale.

     If RGB is an RGB image, the conversion to grayscale is weighted
     based on the luminance values (see 'rgb2ntsc').  Supported classes
     are single, double, uint8 and uint16.

     If RGB is a colormap it is converted into the YIQ space of ntsc.
     The luminance value (Y) is taken to create a gray colormap.

     See also: mat2gray, ntsc2rgb, rgb2ind, rgb2ntsc, rgb2ycbcr.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 43
Convert RGB image or colormap to grayscale.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rgb2lab


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1198
 -- Function File: LAB = rgb2lab (RGB)
 -- Function File: LAB_MAP = rgb2lab (RGB_MAP)
     Transform a colormap or image from sRGB to CIE L*a*b* color space.

     A color in the RGB space consists of red, green, and blue
     intensities.  The input RGB values are interpreted as nonlinear
     sRGB values with the white point D65.  This means the input values
     are assumed to be in the colorimetric (sRGB) colorspace.

     A color in the CIE L*a*b* (or CIE Lab) space consists of lightness
     L* and two color-opponent dimensions a* and b*.  The whitepoint is
     taken as D65.  The CIE L*a*b* colorspace is also a colorimetric
     colorspace.  It is designed to incorporate the human perception of
     color differences.

     Input values of class double, single, uint8 or uint16 are accepted.
     Output class is generally of type double, only input type single
     will result in an output type of single.  The shape of the input is
     conserved.

     note: This function returns slightly different values than the
     Matlab version.  But it has a better "round trip accuracy" (<2e-5)
     for RGB -> Lab -> RGB.

     See also: lab2rgb, rgb2xyz, rgb2hsv, rgb2ind, rgb2ntsc.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 66
Transform a colormap or image from sRGB to CIE L*a*b* color space.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
rgb2xyz


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1091
 -- Function File: XYZ = rgb2xyz (RGB)
 -- Function File: XYZ_MAP = rgb2xyz (RGB_MAP)
     Transform a colormap or image from sRGB to CIE XYZ color space.

     A color in the RGB space consists of red, green, and blue
     intensities.  The input RGB values are interpreted as nonlinear
     sRGB values with the white point D65.  This means the input values
     are assumed to be in the colorimetric (sRGB) colorspace.

     A color in the CIE XYZ color space consists of three values X, Y
     and Z. Those values are designed to be colorimetric, meaning that
     their values do not depend on the display device hardware.

     Input values of class double, single, uint8 or uint16 are accepted.
     Output class is generally of type double, only input type single
     will result in an output type of single.  The shape of the input is
     conserved.

     note: This function returns slightly different values than the
     Matlab version.  But it has a better "round trip accuracy" (<2e-5)
     for RGB -> XYZ -> RGB.

     See also: xyz2rgb, rgb2lab, rgb2hsv, rgb2ind, rgb2ntsc.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Transform a colormap or image from sRGB to CIE XYZ color space.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
rgb2ycbcr


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1083
 -- Function File: YCBCRMAP = rgb2ycbcr (CMAP)
 -- Function File: YCBCR = rgb2ycbcr (RGB)
 -- Function File: ... = rgb2ycbcr (..., [KB KR])
 -- Function File: ... = rgb2ycbcr (..., STANDARD)
     Convert RGB values to YCbCr.

     The conversion changes the image RGB or colormap CMAP, from the RGB
     color model to YCbCr (luminance, chrominance blue, and chrominance
     red).  RGB must be of class double, single, uint8, or uint16.

     The formula used for the conversion is dependent on two constants,
     KB and KR which can be specified individually, or according to
     existing standards:

     "601" (default)
          According to the ITU-R BT.601 (formerly CCIR 601) standard.
          Its values of KB and KR are 0.114 and 0.299 respectively.
     "709"
          According to the ITU-R BT.709 standard.  Its values of KB and
          KR are 0.0722 and 0.2116 respectively.
     "2020"
          According to the ITU-R BT.2020 standard.  Its values of KB and
          KR are 0.0593 and 0.2627 respectively.

     See also: hsv2rgb, ntsc2rgb, rgb2hsv, rgb2ntsc.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 28
Convert RGB values to YCbCr.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
rho_filter


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2518
 -- Function File: FILTERED = rho_filter (PROJ, TYPE, SCALING)

     Filters the parallel ray projections in the columns of PROJ,
     according to the filter type chosen by TYPE.  TYPE can be chosen
     from
        * 'none'
        * 'Ram-Lak' (default)
        * 'Shepp-Logan'
        * 'Cosine'
        * 'Hann'
        * 'Hamming'

     If given, SCALING determines the proportion of frequencies below
     the nyquist frequency that should be passed by the filter.  The
     window function is compressed accordingly, to avoid an abrupt
     truncation of the frequency response.

 -- Function File: [FILTERED, FILTER] = rho_filter (...)

     This form also returns the frequency response of the filter in the
     vector FILTER.

     Performs rho filtering on the parallel ray projections provided.

     Rho filtering is performed as part of the filtered back-projection
     method of CT image reconstruction.  It is the filtered part of the
     name.  The simplest rho filter is the Ramachadran-Lakshminarayanan
     (Ram-Lak), which is simply |rho|, where rho is the radial component
     of spatial frequency.  However, this can cause unwanted
     amplification of noise, which is what the other types attempt to
     minimise, by introducing roll-off into the response.  The Hann and
     Hamming filters multiply the standard response by a Hann or Hamming
     window, respectively.  The cosine filter is the standard response
     multiplied by a cosine shape, and the Shepp-Logan filter multiplies
     the response with a sinc shape.  The 'none' filter performs no
     filtering, and is included for completeness and to enable
     incorporating this function easily into scripts or functions that
     may offer the ability to choose to apply no filtering.

     This function is designed to be used by the function 'iradon', but
     has been exposed to facilitate custom inverse radon transforms and
     to more clearly break down the process for educational purposes.
     The operations
              filtered = rho_filter (proj);
              reconstruction = iradon (filtered, 1, 'linear', 'none');
     are exactly equivalent to
              reconstruction = iradon (proj, 1, 'linear', 'Ram-Lak');

     Usage example:
            P = phantom ();
            projections = radon (P);
            filtered_projections = rho_filter (projections, 'Hamming');
            reconstruction = iradon (filtered_projections, 1, 'linear', 'none');
            figure, imshow (reconstruction, [])


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Filters the parallel ray projections in the columns of PROJ, according
to the fi



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
roicolor


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 549
 -- Function File: BW = roicolor (A, LOW, HIGH)
 -- Function File: BW = roicolor (A,V)
     Select a Region Of Interest of an image based on color.

     BW = roicolor(A,low,high) selects a region of interest (ROI) of an
     image A returning a black and white image in a logical array (1 for
     pixels inside ROI and 0 outside ROI), which is formed by all pixels
     whose values lie within the colormap range specified by [LOW HIGH].

     BW = roicolor(A,v) selects a region of interest (ROI) formed by all
     pixels that match values in V.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 55
Select a Region Of Interest of an image based on color.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 4
std2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 144
 -- Function File: S= std2 (I)
     Returns the standard deviation for a 2d real type matrix.  Uses
     'std (I(:))'

     See also: mean2,std.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 57
Returns the standard deviation for a 2d real type matrix.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
stdfilt


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1072
 -- Function File: S = stdfilt (IM)
 -- Function File: S = stdfilt (IM, DOMAIN)
 -- Function File: S = stdfilt (IM, DOMAIN, PADDING, ...)
     Computes the local standard deviation in a neighbourhood around
     each pixel in an image.

     The standard deviation of the pixels of a neighbourhood is computed
     as

          S = sqrt ((sum (X - MU).^2)/(N-1))

     where MU is the mean value of the pixels in the neighbourhood, N is
     the number of pixels in the neighbourhood.  So, an unbiased
     estimator is used.

     The neighbourhood is defined by the DOMAIN binary mask.  Elements
     of the mask with a non-zero value are considered part of the
     neighbourhood.  By default a 3 by 3 matrix containing only non-zero
     values is used.

     At the border of the image, extrapolation is used.  By default
     symmetric extrapolation is used, but any method supported by the
     'padarray' function can be used.  Since extrapolation is used, one
     can expect a lower deviation near the image border.

     See also: std2, paddarray, entropyfilt.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Computes the local standard deviation in a neighbourhood around each
pixel in an



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
stretchlim


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2441
 -- Function File: stretchlim (I)
 -- Function File: stretchlim (RGB)
 -- Function File: stretchlim (..., TOL)
     Find limits to contrast stretch an image.

     Returns a 2 element column vector, '[LOW; HIGH]', with the pair of
     intensities to contrast stretch I which saturates at most TOL of
     the image.  The output of this function matches the input expected
     by 'imadjust'.

     The input argument TOL, controls the fraction of the image to be
     saturated and defaults to '[0.01 0.99]', i.e., a 1% saturation on
     both sides of the image histogram.  It can be specified in two
     ways:

        * a two element vector with lower and higher fraction of the the
          image to be saturated.  These values must be in the range [0
          1], the display range of images of floating point class.

        * a scalar value with the fraction of image to be saturated on
          each side; e.g., a TOL with a value of '0.05' is equivalent to
          '[0.05 0.95]'.  This value must be in the range '[0 0.5]'.

     A common use case wanting to maximize contrast without causing any
     saturation.  In such case TOL should be 0 (zero).  It is the
     equivalent to '[min(I(:)); max(I(:))]' for a single plane.

     The return values are of class double and in the range [0 1]
     regardless of the input image class.  These values are scaled in
     the image class range (see 'im2double').

     If the input is a RGB image, i.e., the 3rd dimension has length 3,
     then it returns a '[2 3]' matrix with separate limits for each
     colour.  It will actually do this for each plane, so an input of
     size, '[M N P]' will return a '[2 P]' matrix.

     Higher dimensions of I are also valid.  As in the 3 dimensional
     case, the limits for each 2 dimensional plane are returned in a 2
     row vector for each 2 dimensional plane, one dimension below.  That
     is, an input of size '[M N P Q R]' will return an array of size '[2
     P Q R]'.

     Note the detail that TOL is the maximum fraction of saturation.  It
     is rare that there is a value for that exact saturation.  In such
     case, 'stretchlim' will always round down and saturate less.  TOL
     is the saturation limit.  For example, if TOL is '0.10', but there
     are only values that will lead to 5 or 11% saturation, it will
     return the value for a 5% saturation.

     See also: brighten, contrast, histeq, imadjust.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 41
Find limits to contrast stretch an image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
subimage


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 797
 -- Function File: subimage (BW)
 -- Function File: subimage (IMG)
 -- Function File: subimage (RGB)
 -- Function File: subimage (IND, CMAP)
 -- Function File: subimage (X, Y, ...)
 -- Function File: H = subimage (...)
     Display images in subplots.

     A single figure, even with multiple subplots, is limited to a
     single colormap.  With the exception of truecolor images, images
     will use the figure colormap which make it impossible to have
     multiple images with different display.  This function transforms
     any image in truecolor to workaround this limitation.

     The new subimage is displayed as if using 'image'.  The optional
     arguments X and Y are passed to 'image' to specify the range of the
     axis labels.

     See also: image, imagesc, imshow, subplot.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 27
Display images in subplots.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
tformfwd


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 499
 -- Function File: [XY] = tformfwd (T, UV)
 -- Function File: [X, Y] = tformfwd (T, U, V)

     Given a transform structure T, transform coordinates UV in the
     input space into coordinates XY in the output space.

     Input and output coordinates may be given/retrieved either as a
     n-by-2 array, or as two n-by-1 vectors.

     The function makes use of the "forward_fcn" field of the transform
     structure T, which should thus be defined.

     See also: maketform, cp2tform, tforminv.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Given a transform structure T, transform coordinates UV in the input
space into 



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 8
tforminv


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 499
 -- Function File: [UV] = tforminv (T, XY)
 -- Function File: [U, V] = tforminv (T, X, Y)

     Given a transform structure T, transform coordinates XY in the
     output space into coordinates UV in the input space.

     Input and output coordinates may be given/retrieved either as a
     n-by-2 array, or as two n-by-1 vectors.

     The function makes use of the "inverse_fcn" field of the transform
     structure T, which should thus be defined.

     See also: maketform, cp2tform, tformfwd.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 80
Given a transform structure T, transform coordinates XY in the output
space into



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 13
tiff_tag_read


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 2195
 -- Function File: [VALUE, OFFSET] = tiff_tag_read (FILE, TAG)
 -- Function File: [VALUE, OFFSET] = tiff_tag_read (FILE, TAG, IFD)
 -- Function File: [VALUE, OFFSET] = tiff_tag_read (FILE, TAG, "all")
     Read value of TAGs from TIFF files.

     FILE must be a TIFF file and TAG should be a tag ID. To check
     multiple tags, TAG can be a vector.  If IFD is supplied, only those
     IFDs (Image File Directory) will be read.  As with TAG, multiple
     IFDs can be checked by using a vector or with the string 'all'.  By
     default, only the first IFD is read.

     VALUE and OFFSET will be a matrix with a number of rows and columns
     equal to the number of TAGs and IFDs requested.  The index relate
     to the same order as the input.  OFFSET has the same structure as
     VALUE and when equal to 1 its matching value on VALUE will be an
     offset to a position in the file.

     TAGs that can't be found will have a value of 0 and the
     corresponding OFFSET will be 2.

     If an error occurs when reading FILE (such as lack of permissions
     of file is not a TIFF file), OFFSET is set to -1 and VALUE contains
     the error message.

     See the following examples:
          ## read value of tag 258 on IFD 1 (`off' will be 1 if `val' is an offset or 2 if not found)
          [val, off] = tiff_tag_read (filepath, 258);

          ## read value 258, 262, 254 o IFD 1 (`val' and `off' will be a 1x3 matrix)
          [val, off] = tiff_tag_read (filepath, [258 262 254]);
          if (off(1) == -1), error ("something happened: %s", val); endif
          off(2,1)   # will be 1 if val(2,1) is an offset to a file position or 2 if tag was not found
          val(2,1)   # value of tag 262 on IFD 1

          ## read value 258, 262, 254 on the first 10 IFDs 1 (`val' and `off' will be a 1x10 matrix)
          [val, off] = tiff_tag_read (filepath, [258 262 254], 1:10);
          val(2,5)   # value of tag 262 on IFD 5

          ## read value 258, 262, 254 o IFD 1 (`val' and `off' will be a 1x3 matrix)
          [val, off] = tiff_tag_read (filepath, [258 262 254], "all");
          val(2,end)   # value of tag 262 on the last IFD

     See also: imread, imfinfo.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 35
Read value of TAGs from TIFF files.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 10
viscircles


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1241
 -- Function File: viscircles (CENTERS, RADII)
 -- Function File: viscircles (HAX, CENTERS, RADII)
 -- Function File: viscircles (..., PROPERTY, VALUE)
 -- Function File: H = viscircles (...)
     Draw circles on figure.

     Circles are specified by a Nx2 matrix CENTERS with x,y coordinates
     per row, and a N length vector RADII.

          ## draw circles at [10 20] and [-10 -20] coordinates
          ## with radius of 10 and 20 respectively
          viscircles ([10 20; -10 -20], [10 20])

     The appearance of the drawn circles can be configured with the
     following properties names:

     "Color"
          The color of the circle.  Defaults to "red".  Can be defined
          via the color names or RGB triplets.  See the help text for
          'plot' for further details on specifying colors in figures.

     "LineStyle"

          The line style of the circle.  Defaults to "-" (solid line).
          See the help text for 'plot' for possible values.

     "LineWidth"
          The width of the circle line.  Defaults to 2.

     "EnhanceVisibility"
          Enhance visibility by drawing a white circle under the colored
          circle.  Must be a logical value.  Defaults to true.

     See also: plot, line.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 23
Draw circles on figure.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 14
wavelength2rgb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1168
 -- Function File: RGB = wavelength2rgb (WAVELENGTH)
 -- Function File: RGB = wavelength2rgb (WAVELENGTH, CLASS)
 -- Function File: RGB = wavelength2rgb (WAVELENGTH, CLASS, GAMMA)
     Convert wavelength in nm into an RGB value set.

     Given a N-dimensional matrix WAVELENGTH with color values in nm,
     returns a RGB image with N+3 dimensions.

          wavelength2rgb (400)
              => [0.51222 0.00000 0.70849]

          wavelength2rgb ([400 410])
              => 0.51222   0.49242
              => 0         0
              => 0.70849   0.85736

     The RGB class can be specified with CLASS.  Possible values are
     double (default), single, uint8, uint16, and int16.

          wavelength2rgb (400)
              => 0.51222  0.00000  0.70849

          wavelength2rgb (400, "uint8")
              => 131    0  181

     The luminance of colors can be adjusted with GAMMA which must a
     scalar value in the range [0 1].  Defaults to 0.8.

     Reference:
        * 
          <http://stackoverflow.com/questions/2374959/algorithm-to-convert-any-positive-integer-to-an-rgb-value>
        * <http://www.midnightkite.com/color.html> per Dan Bruton


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 47
Convert wavelength in nm into an RGB value set.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
wiener2


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1145
 -- Function File: J =  wiener2 (I)
 -- Function File: J =  wiener2 (I, [M, N])
 -- Function File: J =  wiener2 (I, NOISE)
 -- Function File: J =  wiener2 (I, [M, N], NOISE)
 -- Function File: [J, NOISE] = wiener2 (I, [M, N])
     Apply an adaptive noise reduction filter on a 2D grayscale image.

     The wiener2 function locally applies a linear averaging filter to
     the input image I.  The averaging operation will be performed using
     the given [M, N] neighborhood of each pixel.  The strength of the
     averaging depends on the local variance in this neighborhood and on
     the given variance of the NOISE (of mean zero).  As a result,
     pixels in a region with higher contrast will be smoothed less, and
     pixels in a region with lower contrast will be smoothed more.

     This operation is useful to remove noise from the image, while
     blurring edges much less compared to a global linear averaging
     filter.

     The M-by-N neighborhood defaults to 3-by-3 if not given.  The NOISE
     variance will be estimated by the mean variance in the
     neighborhoods, if not given.

     See also: imfilter, medfilt2.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 65
Apply an adaptive noise reduction filter on a 2D grayscale image.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
xyz2lab


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 989
 -- Function File: LAB = xyz2lab (XYZ)
 -- Function File: LAB_MAP = xyz2lab (XYZ_MAP)
     Transform a colormap or image from CIE XYZ to CIE L*a*b* color
     space.

     A color in the CIE XYZ color space consists of three values X, Y
     and Z. Those values are designed to be colorimetric, meaning that
     their values do not depend on the display device hardware.

     A color in the CIE L*a*b* (or CIE Lab) space consists of lightness
     L* and two color-opponent dimensions a* and b*.  The whitepoint is
     taken as D65.  The CIE L*a*b* colorspace is also a colorimetric
     colorspace.  It is designed to incorporate the human perception of
     color differences.

     Input values of class single and double are accepted.  The shape
     and the class of the input are conserved.

     The return values of L* are normally in the inteval [0, 100] and
     the values of a* and b* in the interval [-127, 127]

     See also: lab2xyz, rgb2lab, rgb2hsv, rgb2ind, rgb2ntsc.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 69
Transform a colormap or image from CIE XYZ to CIE L*a*b* color space.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 7
xyz2rgb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 937
 -- Function File: RGB = xyz2rgb (XYZ)
 -- Function File: RGB_MAP = xyz2rgb (XYZ_MAP)
     Transform a colormap or image from CIE XYZ to sRGB color space.

     A color in the CIE XYZ color space consists of three values X, Y
     and Z. Those values are designed to be colorimetric, meaning that
     their values do not depend on the display device hardware.

     A color in the RGB space consists of red, green, and blue
     intensities.  The output RGB values are calculated to be nonlinear
     sRGB values with the white point D65.  This means the output values
     are in the colorimetric (sRGB) colorspace.

     Input values of class single and double are acceptecd.  The shape
     and the class of the input are conserved.

     note: outside the definition range (0<=R, G, B<=1) this function
     might return different (but also nonsense) values than Matlab.

     See also: rgb2xyz, rgb2lab, rgb2hsv, rgb2ind, rgb2ntsc.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 63
Transform a colormap or image from CIE XYZ to sRGB color space.



# name: <cell-element>
# type: sq_string
# elements: 1
# length: 9
ycbcr2rgb


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 1119
 -- Function File: CMAP = ycbcr2rgb (YCBCRMAP)
 -- Function File: RGB = ycbcr2rgb (YCBCR)
 -- Function File: ... = ycbcr2rgb (..., [KB KR])
 -- Function File: ... = ycbcr2rgb (..., STANDARD)
     Convert YCbCr color space to RGB.

     The conversion changes the image YCBCR or colormap YCBCRMAP, from
     the YCbCr (luminance, chrominance blue, and chrominance red) color
     space to RGB values.  YCBCR must be of class double, single, uint8,
     or uint16.

     The formula used for the conversion is dependent on two constants,
     KB and KR which can be specified individually, or according to
     existing standards:

     "601" (default)
          According to the ITU-R BT.601 (formerly CCIR 601) standard.
          Its values of KB and KR are 0.114 and 0.299 respectively.
     "709"
          According to the ITU-R BT.709 standard.  Its values of KB and
          KR are 0.0722 and 0.2116 respectively.
     "2020"
          According to the ITU-R BT.2020 standard.  Its values of KB and
          KR are 0.0593 and 0.2627 respectively.

     See also: hsv2rgb, ntsc2rgb, rgb2hsv, rgb2ntsc, rgb2ycbcr.


# name: <cell-element>
# type: sq_string
# elements: 1
# length: 33
Convert YCbCr color space to RGB.





